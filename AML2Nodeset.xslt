<?xml version="1.0" encoding="UTF-8"?><xsl:stylesheet version="2.0" 	xmlns:fn2="http://whatever"	xmlns:fn="http://www.w3.org/2005/xpath-functions" 	xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 	xsi:noNamespaceSchemaLocation="http://www.dke.de/CAEX" 	xmlns:caex="http://www.dke.de/CAEX" 	xmlns:exslt="http://exslt.org/common" 	xmlns="http://opcfoundation.org/UA/2011/03/UANodeSet.xsd" 	xmlns:ua="http://opcfoundation.org/UA/2011/03/UANodeSet.xsd" 	exclude-result-prefixes="#default caex xsi xsl exslt fn ua">	<!-- ******************************************************************* Helper**************************************************************** -->	<!-- if there is no xmlns given (e.g. V2.15 examples we need xsi:noNamespaceLocation -->	<xsl:output method="xml" version="1.0" encoding="UTF-8" indent="yes" omit-xml-declaration="yes" cdata-section-elements="String"/>	<xsl:function name="exslt:node-set">		<xsl:param name="rtf"/>		<xsl:sequence select="$rtf"/>	</xsl:function>		<xsl:function name="fn2:remove-space">		<xsl:param name="value"/>		<xsl:value-of select="replace($value, ' ', '')"/>	</xsl:function>	<!-- Does not work with MSXSL -->	<!--xsl:function name="exslt:ends-with">		<xsl:param name="target"/>		<xsl:param name="suffix"/>		<xsl:sequence select="$suffix = substring($target, string-length($target) - string-length($suffix) + 1)"/>	</xsl:function--><!-- ******************************************************************* Translate differnt versions of AML to a common namespace**************************************************************** -->	<!-- 		translate V2 files to V3 namespace 	    this allows us to use the same translation rules for AML V2 and V3 	-->	<xsl:template match="CAEXFile">		<xsl:variable name="withNS">			<xsl:element name="{name(.)}" namespace="http://www.dke.de/CAEX">				<xsl:copy-of select="@*"/>				<xsl:apply-templates mode="copy-to-new-ns"/>			</xsl:element>		</xsl:variable>		<xsl:apply-templates select="$withNS"/>	</xsl:template>	<xsl:template mode="copy-to-new-ns" match="*">		<xsl:element name="{name(.)}" namespace="http://www.dke.de/CAEX">			<xsl:copy-of select="@*"/>			<xsl:apply-templates mode="copy-to-new-ns"/>		</xsl:element>	</xsl:template>	<xsl:template match="@*"/>	<!-- ******************************************************************* Prepare translation**************************************************************** -->	<!--ToDo: ignore ChangeMode=state-->	<!--xsl:template match="@*[./name()='ChangeMode']">		<xsl:comment>ChangeMode will be ignored due to error</xsl:comment>	</xsl:template-->	<!-- Parsing of SystemUnitClassLib, InterfaceClassLib, RoleClassLib-->	<xsl:include href="LibraryParsing.xslt"/>	<xsl:include href="DatatypeTranslation.xslt"/>	<!-- Translation of SystemUnitClassLib, InterfaceClassLib, RoleClassLib-->	<xsl:include href="LibraryTranslation.xslt"/>	<!-- Collect all namespaces -->	<xsl:variable name="NamespaceUris">		<NamespaceUris>			<Uri>http://opcfoundation.org/UA/AML/</Uri>			<Uri>http://opcfoundation.org/UA/AML/MyInstances</Uri>                 			<!-- use local-name() here because namespace is not equalized at this point, yet -->			<xsl:for-each select="*[local-name()='CAEXFile']/*[local-name()='InterfaceClassLib']">				<Uri>					<xsl:value-of select="concat('http://opcfoundation.org/UA/AML/', @Name)"/>				</Uri>			</xsl:for-each>			<xsl:for-each select="*[local-name()='CAEXFile']/*[local-name()='RoleClassLib']">				<Uri>					<xsl:value-of select="concat('http://opcfoundation.org/UA/AML/', @Name)"/>				</Uri>			</xsl:for-each>			<xsl:for-each select="*[local-name()='CAEXFile']/*[local-name()='SystemUnitClassLib']">				<Uri>					<xsl:value-of select="concat('http://opcfoundation.org/UA/AML/', @Name)"/>				</Uri>			</xsl:for-each>		</NamespaceUris>	</xsl:variable>	<!-- Collect all InternalLinks and equalize namespace-->	<xsl:variable name="InternalLinks">		<InternalLinks>			<xsl:for-each select="//*[local-name()='InternalLink']">				<InternalLink>					<xsl:copy-of select="@Name"/>					<xsl:attribute name="ParentSideA" select="substring-before(@RefPartnerSideA,':')"/>					<xsl:attribute name="InterfaceSideA" select="substring-after(@RefPartnerSideA,':')"/>					<xsl:attribute name="ParentSideB" select="substring-before(@RefPartnerSideB,':')"/>					<xsl:attribute name="InterfaceSideB" select="substring-after(@RefPartnerSideB,':')"/>				</InternalLink>			</xsl:for-each>		</InternalLinks>	</xsl:variable>	<!-- ***************************************************************************  ***  Skeleton********************************************************************************* -->	<!-- .........................................................................		CAEXFile: Create Skeleton	.........................................................................-->	<xsl:template match="caex:CAEXFile">		<!--Test><xsl:copy-of select="$InternalLinks"/></Test-->			<UANodeSet xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="http://opcfoundation.org/UA/2011/03/UANodeSet.xsd">			<xsl:comment>			Documentation			===============			To support both CAEX V2.15 and CAEX V3.0 we add the namespace to CAEX V2.15 before translation. 			UANodeSet			=============			TODOs:				- Do we need aliases?? 					- to be clarified with UA -> Miriam				    - only used ones or standard template set of aliases					- purpose? drawback								- InternalLinks are not translated, yet.				- Missing translation for UtcTime/DateTime				- How to use Table 14 in DataTypeMapping v5.0? -> Add mapping to translation table				- no HasTypeDefinition available if there was no SystemUnitClass (see "BPR_005E_ExternalDataReference_Examples_Jul2016.aml")				- use correct HasTypeDefinition				- are spaces allowed in NodeId string as part if the ID? 				    - to be clarified with AML if spaces are allowed (Part 1) -> Miriam					- Example in AR APC all Classes AutomationProjectConfigurationRoleClassLib/DeviceItem Attributes					- necessary for nodeID (BrowseName keeps space), thus deleted				- are '{GUID}' and 'GUID' equal? -> will be handled as equivalent				- InterfaceClasses have no specific UA "base structure", but are also of type ObjectType -> how to distinguish between SUC and IC				- AdditionalInformation is handled as blackbox (no ID)				- AdditionalInformation AutomationMLVersion				- from UA to AML: what if we have no "file name" in UA XML (Nodeset has no name) (which element to use as filename)				- XSL + script for generation of MD5 hash								- How to understand the hierarchical elements (incl. HasTypeDefinition)?				- support AttributeTypeLib (CAEX V3.0)			</xsl:comment>			<xsl:copy-of select="$NamespaceUris"/>			<Models>				<Model ModelUri="http://opcfoundation.org/UA/AMLLibs/">					<RequiredModel ModelUri="http://opcfoundation.org/UA/AML/"/>					<RequiredModel ModelUri="http://opcfoundation.org/UA/" Version="1.04" PublicationDate="2019-05-01T00:00:00Z"/>				</Model>			</Models>			<Aliases>				<Alias Alias="Boolean">i=1</Alias>				<Alias Alias="SByte">i=2</Alias>				<Alias Alias="Byte">i=3</Alias>				<Alias Alias="Int16">i=4</Alias>				<Alias Alias="UInt16">i=5</Alias>				<Alias Alias="Int32">i=6</Alias>				<Alias Alias="UInt32">i=7</Alias>				<Alias Alias="Int64">i=8</Alias>				<Alias Alias="UInt64">i=9</Alias>				<Alias Alias="Float">i=10</Alias>				<Alias Alias="Double">i=11</Alias>				<Alias Alias="DateTime">i=13</Alias>				<Alias Alias="String">i=12</Alias>				<Alias Alias="ByteString">i=15</Alias>				<Alias Alias="Guid">i=14</Alias>				<Alias Alias="XmlElement">i=16</Alias>				<Alias Alias="NodeId">i=17</Alias>				<Alias Alias="ExpandedNodeId">i=18</Alias>				<Alias Alias="QualifiedName">i=20</Alias>				<Alias Alias="LocalizedText">i=21</Alias>				<Alias Alias="StatusCode">i=19</Alias>				<Alias Alias="Structure">i=22</Alias>				<Alias Alias="Number">i=26</Alias>				<Alias Alias="Integer">i=27</Alias>				<Alias Alias="UInteger">i=28</Alias>				<Alias Alias="HasComponent">i=47</Alias>				<Alias Alias="HasProperty">i=46</Alias>				<Alias Alias="Organizes">i=35</Alias>				<Alias Alias="HasEventSource">i=36</Alias>				<Alias Alias="HasNotifier">i=48</Alias>				<Alias Alias="HasSubtype">i=45</Alias>				<Alias Alias="HasTypeDefinition">i=40</Alias>				<Alias Alias="HasModellingRule">i=37</Alias>				<Alias Alias="HasEncoding">i=38</Alias>				<Alias Alias="HasDescription">i=39</Alias>				<Alias Alias="Duration">i=290</Alias>				<Alias Alias="HasAMLInternalLink">ns=1;i=4002</Alias>				<Alias Alias="HasAMLRoleReference">TODO</Alias>				<Alias Alias="CAEXObjectType">n=1;i=1001</Alias>			</Aliases>			<xsl:comment>			CAEXFile			===============			TODOs:				- is this the correct translation (AMLFile = Object)? -> currently yes				- do we really need InstanceHierarchies, InterfaceClassLibs and other organizing elements? --> variable in xslt to include or not, flag in xslt if things were included				- How to model ExternalReferences?					- Include external libraries or include parts of the models from an external file (e.g. in case of big models)					- Option 1: merge external references into AML file before applying XSL transformation (no external references in AML file)					- Option 2: each externally referenced AML model is translated into a OPC UA namespace named with the ExternalReference alias name ïƒ  each external reference you find inside the AML model is like internal AML reference, but references the other namespace					- Option 3: keep ExternalReferences as property of CAEXFile object; in case of an external reference inside the model, no linking to another OPC UA node is possible, but information is persisted					- Preferences: 2-1-3 or 1-2-3/2-1-3 					- report in AML TAC				- How to handle DefaultValues of attributes?			</xsl:comment>			<UAObject>				<xsl:attribute name="NodeId">					<xsl:value-of select="'ns=2;s=CAEXFile'"/>				</xsl:attribute>				<xsl:attribute name="BrowseName">					<xsl:value-of select="@FileName"/>				</xsl:attribute>				<DisplayName>					<xsl:value-of select="@FileName"/>				</DisplayName>				<xsl:copy-of select="caex:Description"/>				<References>					<xsl:comment>Type definition: CAEXFileType</xsl:comment>					<Reference ReferenceType="HasTypeDefinition">ns=1;i=1005</Reference>					<xsl:if test="@FileName">						<xsl:comment>FileName</xsl:comment>						<Reference ReferenceType="HasProperty">ns=2;s=CAEXFile_FileName</Reference>					</xsl:if>					<xsl:if test="@SchemaVersion">						<xsl:comment>SchemaVersion</xsl:comment>						<Reference ReferenceType="HasProperty">ns=2;s=CAEXFile_SchemaVersion</Reference>					</xsl:if>					<xsl:if test="caex:SuperiorStandardVersion">						<xsl:comment>SuperiorStandardVersion</xsl:comment>						<Reference ReferenceType="HasProperty">ns=2;s=CAEXFile_SuperiorStandardVersion</Reference>					</xsl:if>					<xsl:comment>InstanceHierarchy</xsl:comment>					<xsl:if test="//caex:InstanceHierarchy">						<Reference ReferenceType="HasComponent">ns=2;s=CAEXFile_InstanceHierarchies</Reference>					</xsl:if>					<xsl:comment>Libraries</xsl:comment>					<xsl:if test="//caex:InterfaceClassLib">						<Reference ReferenceType="HasComponent">ns=2;s=CAEXFile_InterfaceClassLibs</Reference>					</xsl:if>					<xsl:if test="//caex:RoleClassLib">						<Reference ReferenceType="HasComponent">ns=2;s=CAEXFile_RoleClassLibs</Reference>					</xsl:if>					<xsl:if test="//caex:SystemUnitClassLib">						<Reference ReferenceType="HasComponent">ns=2;s=CAEXFile_SystemUnitClassLibs</Reference>					</xsl:if>					<xsl:for-each select="caex:AdditionalInformation">						<xsl:variable name="AttributeName">							<xsl:call-template name="NumberedAttributeName"/>						</xsl:variable>						<xsl:variable name="BrowseName">							<xsl:call-template name="AttributeBrowseName"/>						</xsl:variable>						<xsl:comment>							<xsl:value-of select="concat('AdditionalInformation: ', $BrowseName)"/>						</xsl:comment>						<Reference ReferenceType="HasProperty">							<xsl:value-of select="concat('ns=2;s=CAEXFile_', $AttributeName)"/>						</Reference>					</xsl:for-each>					<xsl:comment>TODO: should the SourceDocumentInformation be available as attributes?</xsl:comment>					<xsl:for-each select="caex:SourceDocumentInformation">						<xsl:variable name="AttributeName">							<xsl:call-template name="NumberedAttributeName"/>						</xsl:variable>						<xsl:comment>							<xsl:value-of select="concat('SourceDocumentInformation: ', $AttributeName)"/>						</xsl:comment>						<Reference ReferenceType="HasProperty">							<xsl:value-of select="concat('ns=2;s=CAEXFile_', $AttributeName)"/>						</Reference>					</xsl:for-each>					<Reference ReferenceType="Organizes" IsForward="false">ns=1;i=5006</Reference>				</References>			</UAObject>			<xsl:apply-templates select="@FileName"/>			<xsl:apply-templates select="@SchemaVersion"/>			<xsl:apply-templates select="./caex:SuperiorStandardVersion"/>			<xsl:comment>			AdditionalInformation			===============			TODOs:				- do we need an extra UAObjectType for additional information? -> no use content of value as marker			    - which version (1. or 2.) is the correct translation of an AdditionalInformation?			</xsl:comment>			<xsl:apply-templates select="./caex:AdditionalInformation"/>			<xsl:apply-templates select="./caex:SourceDocumentInformation"/>			<xsl:comment>			InstanceHierarchies			===============			TODOs:				- do we need a InstanceHierarchies node? What was the result of the discussion? -> variable in xslt to include or not, flag in xslt if things were included			    - Complete References				- Do we need BackwardReferences here?				- Test child of AutomationMLBaseRole/UABaseObjectType				- currently only type definition from Libraries are supported -> support HasTypeDefinition from current namespace			</xsl:comment>			<xsl:call-template name="HierarchicalElement">				<xsl:with-param name="Name" select="'InstanceHierarchies'"/>				<xsl:with-param name="ChildName" select="'InstanceHierarchy'"/>			</xsl:call-template>			<xsl:comment>			InterfaceClassLibs			===============			TODOs:				- do we need a InterfaceClassLibs node? What was the result of the discussion? -> variable in xslt to include or not, flag in xslt if things were included			</xsl:comment>			<xsl:call-template name="HierarchicalElement">				<xsl:with-param name="Name" select="'InterfaceClassLibs'"/>				<xsl:with-param name="ChildName" select="'InterfaceClassLib'"/>			</xsl:call-template>			<xsl:comment>			RoleClassLibs			===============			TODOs:				- ...			</xsl:comment>			<xsl:call-template name="HierarchicalElement">				<xsl:with-param name="Name" select="'RoleClassLibs'"/>				<xsl:with-param name="ChildName" select="'RoleClassLib'"/>			</xsl:call-template>			<xsl:comment>			SystemUnitClassLibs			===============			TODOs:				- check all inner elements, e.g. attributes, etc.			</xsl:comment>			<xsl:call-template name="HierarchicalElement">				<xsl:with-param name="Name" select="'SystemUnitClassLibs'"/>				<xsl:with-param name="ChildName" select="'SystemUnitClassLib'"/>			</xsl:call-template>		</UANodeSet>	</xsl:template>	<!-- *************************************************************************** *** InstanceHierarchy***************************************************************************-->	<xsl:template match="caex:InstanceHierarchy">		<xsl:comment>			<xsl:value-of select="concat('InstanceHierarchy: ', @Name)"/>		</xsl:comment>		<UAObject>			<xsl:attribute name="NodeId">				<xsl:value-of select="concat('ns=2;s=InstanceHierarchy_', fn2:remove-space(@Name))"/>			</xsl:attribute>			<xsl:attribute name="BrowseName">				<xsl:value-of select="@Name"/>			</xsl:attribute>			<DisplayName>				<xsl:value-of select="@Name"/>			</DisplayName>			<xsl:copy-of select="caex:Description"/>			<References>				<Reference ReferenceType="HasTypeDefinition">i=61</Reference>				<Reference ReferenceType="Organizes" IsForward="false">ns=1;i=5005</Reference>				<xsl:comment>Backward reference to CAEX InstanceHierarchies</xsl:comment>				<Reference ReferenceType="HasComponent" IsForward="false">ns=2;s=CAEXFile_InstanceHierarchies</Reference>				<xsl:for-each select="caex:InternalElement">					<xsl:comment>						<xsl:value-of select="concat('InternalElement: ', @Name)"/>					</xsl:comment>					<Reference ReferenceType="HasComponent">						<xsl:value-of select="concat('ns=2;g={', @ID, '}')"/>					</Reference>				</xsl:for-each>			</References>		</UAObject>		<xsl:apply-templates select="node()"/>	</xsl:template>	<!-- ***************************************************************************  ***  Attributes********************************************************************************* -->	<!-- .........................................................................		Helper to translate attributes and values	.........................................................................-->	<xsl:template name="NumberedAttributeName">		<xsl:choose>			<xsl:when test="position()=1">				<xsl:value-of select="fn2:remove-space(name(.))"/>			</xsl:when>			<xsl:otherwise>				<xsl:value-of select="concat(fn2:remove-space(name(.)),'_', position())"/>			</xsl:otherwise>		</xsl:choose>	</xsl:template>	<xsl:template name="AttributeBrowseName">		<xsl:variable name="AttributeName">			<xsl:call-template name="NumberedAttributeName"/>		</xsl:variable>		<xsl:choose>			<xsl:when test="name(*[1])!=''">				<xsl:value-of select="name(*[1])"/>			</xsl:when>			<xsl:when test="name(@*[1])!=''">				<xsl:value-of select="name(@*[1])"/>			</xsl:when>			<xsl:otherwise>				<xsl:value-of select="$AttributeName"/>			</xsl:otherwise>		</xsl:choose>	</xsl:template>	<xsl:template name="AttributeVariable">		<xsl:param name="ObjectName"/>		<xsl:param name="ParentId"/>		<xsl:param name="ParentIdType"/>		<xsl:param name="Namespace"/>		<xsl:param name="AttributeName"/>		<xsl:param name="BrowseName" select="$AttributeName"/>		<xsl:param name="AttributeValue"/>		<!-- Create property -->		<xsl:comment>			<xsl:text>Attribute: </xsl:text>			<xsl:value-of select="$ObjectName"/>.<xsl:value-of select="$BrowseName"/>		</xsl:comment>		<UAVariable>			<xsl:attribute name="NodeId">				<xsl:choose>					<!--question: first when with =g or =s-->					<xsl:when test="$ParentIdType='g' and starts-with($ParentId, '{')">						<xsl:value-of select="concat($Namespace, ';s=', $ParentId, '_',fn2:remove-space($AttributeName))"/>					</xsl:when>					<xsl:when test="$ParentIdType='g'">						<xsl:value-of select="concat($Namespace, ';s={', $ParentId, '}_',fn2:remove-space($AttributeName))"/>					</xsl:when>					<xsl:otherwise>						<xsl:value-of select="concat($Namespace, ';s=', $ParentId, '_', fn2:remove-space($AttributeName))"/>					</xsl:otherwise>				</xsl:choose>			</xsl:attribute>			<xsl:attribute name="BrowseName">				<xsl:value-of select="$BrowseName"/>			</xsl:attribute>			<xsl:attribute name="ParentNodeId">				<xsl:choose>					<xsl:when test="$ParentIdType='g' and starts-with($ParentId, '{')">						<xsl:value-of select="concat($Namespace, ';g=', fn2:remove-space($ParentId))"/>					</xsl:when>					<xsl:when test="$ParentIdType='g'">						<xsl:value-of select="concat($Namespace, ';g={', fn2:remove-space($ParentId), '}')"/>					</xsl:when>					<xsl:otherwise>						<xsl:value-of select="concat($Namespace, ';s=', fn2:remove-space($ParentId))"/>					</xsl:otherwise>				</xsl:choose>			</xsl:attribute>			<xsl:attribute name="DataType">String</xsl:attribute>			<DisplayName>				<xsl:value-of select="$BrowseName"/>			</DisplayName>			<References>				<Reference ReferenceType="HasTypeDefinition">i=68</Reference>			</References>			<Value>				<xsl:copy-of select="$AttributeValue"/>			</Value>		</UAVariable>	</xsl:template>	<xsl:template name="StringAttributeVariable">		<xsl:param name="ObjectName"/>		<xsl:param name="ParentId"/>		<xsl:param name="ParentIdType"/>		<xsl:param name="Namespace"/>		<xsl:param name="AttributeName"/>		<xsl:param name="BrowseName" select="$AttributeName"/>		<xsl:param name="AttributeValue"/>		<xsl:variable name="UnescapedAttribute">			<xsl:call-template name="AttributeVariable">				<xsl:with-param name="ObjectName" select="$ObjectName"/>				<xsl:with-param name="ParentId" select="$ParentId"/>				<xsl:with-param name="ParentIdType" select="$ParentIdType"/>				<xsl:with-param name="Namespace" select="$Namespace"/>				<xsl:with-param name="AttributeName" select="$AttributeName"/>				<xsl:with-param name="BrowseName" select="$BrowseName"/>							<xsl:with-param name="AttributeValue">					<!-- use copy-of to allow XML elements as inpute (e.g. for AdditionalInformation) -->					<xsl:copy-of select="$AttributeValue"/>				</xsl:with-param>			</xsl:call-template>				</xsl:variable>		<!-- Add CDATA if necessary -->		<xsl:for-each select="exslt:node-set($UnescapedAttribute)/*">			<xsl:copy>				<xsl:copy-of select="@*"/>				<xsl:copy-of select="*[name()!='Value']"/>				<Value>					<String xmlns="http://opcfoundation.org/UA/2008/02/Types.xsd">						<xsl:choose>							<xsl:when test="*[name()='Value']/*[1]">								<xsl:value-of disable-output-escaping="yes">&lt;![CDATA[</xsl:value-of>								<xsl:copy-of select="*[name()='Value']/*[1]"/>								<xsl:value-of disable-output-escaping="yes">]]&gt;</xsl:value-of>							</xsl:when>							<xsl:otherwise><xsl:value-of select="*[name()='Value']"/></xsl:otherwise>						</xsl:choose>					</String>				</Value>			</xsl:copy>		</xsl:for-each>	</xsl:template>	<!-- .........................................................................	Specific attributes of InternalElements and Class definitions	.........................................................................-->	<xsl:template match="@FileName">		<xsl:variable name="NsId">			<xsl:call-template name="GetNamespaceId"/>		</xsl:variable>		<!-- Create FileName property -->		<xsl:call-template name="StringAttributeVariable">			<xsl:with-param name="ObjectName" select="'CAEXFile'"/>			<xsl:with-param name="ParentId" select="'CAEXFile'"/>			<xsl:with-param name="ParentIdType" select="'s'"/>			<xsl:with-param name="Namespace" select="concat('ns=', $NsId)"/>			<xsl:with-param name="AttributeName" select="'FileName'"/>			<xsl:with-param name="AttributeValue">				<xsl:value-of select="."/>			</xsl:with-param>		</xsl:call-template>	</xsl:template>	<xsl:template match="@SchemaVersion">		<xsl:variable name="NsId">			<xsl:call-template name="GetNamespaceId"/>		</xsl:variable>		<!-- Create SchemaVersion property -->		<xsl:call-template name="StringAttributeVariable">			<xsl:with-param name="ObjectName" select="'CAEXFile'"/>			<xsl:with-param name="ParentId" select="'CAEXFile'"/>			<xsl:with-param name="ParentIdType" select="'s'"/>			<xsl:with-param name="Namespace" select="concat('ns=', $NsId)"/>			<xsl:with-param name="AttributeName" select="'SchemaVersion'"/>			<xsl:with-param name="AttributeValue">				<xsl:value-of select="."/>			</xsl:with-param>		</xsl:call-template>	</xsl:template>	<xsl:template match="@ID">		<xsl:variable name="NsId">			<xsl:call-template name="GetNamespaceId"/>		</xsl:variable>		<!-- Create AML-ID property -->		<xsl:call-template name="StringAttributeVariable">			<xsl:with-param name="ObjectName" select="../@Name"/>			<xsl:with-param name="ParentId" select="../@ID"/>			<xsl:with-param name="ParentIdType" select="'g'"/>			<xsl:with-param name="Namespace" select="concat('ns=', $NsId)"/>			<xsl:with-param name="AttributeName" select="'ID'"/>			<xsl:with-param name="AttributeValue">				<xsl:choose>					<xsl:when test="starts-with(../@ID, '{')">						<xsl:value-of select="../@ID"/>					</xsl:when>					<xsl:otherwise>						<xsl:value-of select="concat('{', ../@ID, '}')"/>					</xsl:otherwise>				</xsl:choose>			</xsl:with-param>		</xsl:call-template>	</xsl:template>	<xsl:template match="caex:SuperiorStandardVersion">		<xsl:variable name="NsId">			<xsl:call-template name="GetNamespaceId"/>		</xsl:variable>		<!-- Create SuperiorStandardVersion property -->		<xsl:call-template name="StringAttributeVariable">			<xsl:with-param name="ObjectName" select="'CAEXFile'"/>			<xsl:with-param name="ParentId" select="'CAEXFile'"/>			<xsl:with-param name="ParentIdType" select="'s'"/>			<xsl:with-param name="Namespace" select="concat('ns=', $NsId)"/>			<xsl:with-param name="AttributeName" select="'SuperiorStandardVersion'"/>			<xsl:with-param name="AttributeValue">				<xsl:value-of select="."/>			</xsl:with-param>		</xsl:call-template>	</xsl:template>	<xsl:template match="caex:Version">		<xsl:variable name="NsId">			<xsl:call-template name="GetNamespaceId"/>		</xsl:variable>		<xsl:choose>			<xsl:when test="name(..)='InterfaceClassLib' or name(..)='RoleClassLib' or name(..)='SystemUnitClassLib'">				<xsl:variable name="LibType">					<xsl:value-of select="name(..)"/>				</xsl:variable>				<xsl:variable name="LibId">					<xsl:value-of select="concat(fn2:remove-space(name(..)), count(../preceding-sibling::node()[name(.)=$LibType])+1)"/>				</xsl:variable>				<xsl:call-template name="StringAttributeVariable">					<xsl:with-param name="ObjectName" select="../@Name"/>					<xsl:with-param name="ParentId" select="$LibId"/>					<xsl:with-param name="ParentIdType" select="'s'"/>					<xsl:with-param name="Namespace" select="concat('ns=', $NsId)"/>					<xsl:with-param name="AttributeName" select="'Version'"/>					<xsl:with-param name="AttributeValue" select="text()"/>				</xsl:call-template>			</xsl:when>			<xsl:when test="name(..)='InstanceHierarchy'">				<xsl:call-template name="StringAttributeVariable">					<xsl:with-param name="ObjectName" select="../@Name"/>					<xsl:with-param name="ParentId" select="'InstanceHierarchy'"/>					<xsl:with-param name="ParentIdType" select="'s'"/>					<xsl:with-param name="Namespace" select="'ns=2'"/>					<xsl:with-param name="AttributeName" select="'Version'"/>					<xsl:with-param name="AttributeValue" select="text()"/>				</xsl:call-template>			</xsl:when>			<xsl:otherwise>				<xsl:call-template name="StringAttributeVariable">					<xsl:with-param name="ObjectName" select="../@Name"/>					<xsl:with-param name="ParentId" select="../@ID"/>					<xsl:with-param name="ParentIdType" select="'g'"/>					<xsl:with-param name="Namespace" select="'ns=2'"/>					<xsl:with-param name="AttributeName" select="'Version'"/>					<xsl:with-param name="AttributeValue" select="text()"/>				</xsl:call-template>			</xsl:otherwise>		</xsl:choose>	</xsl:template>	<xsl:template match="caex:Copyright">		<xsl:variable name="NsId">			<xsl:call-template name="GetNamespaceId"/>		</xsl:variable>		<xsl:call-template name="StringAttributeVariable">			<xsl:with-param name="ObjectName" select="../@Name"/>			<xsl:with-param name="ParentId" select="../@ID"/>			<xsl:with-param name="ParentIdType" select="'g'"/>			<xsl:with-param name="Namespace" select="concat('ns=', $NsId)"/>			<xsl:with-param name="AttributeName" select="'Copyright'"/>			<xsl:with-param name="AttributeValue">				<xsl:copy-of select="."/>			</xsl:with-param>		</xsl:call-template>	</xsl:template>	<xsl:template match="*[name()!='CAEXFile']/caex:AdditionalInformation">		<xsl:variable name="AttributeName">			<xsl:call-template name="NumberedAttributeName"/>		</xsl:variable>		<xsl:variable name="BrowseName">			<xsl:choose>				<xsl:when test="@*[1]"><xsl:value-of select="name(@*[1])"/></xsl:when>				<xsl:when test="*[1]"><xsl:value-of select="name(*[1])"/></xsl:when>				<xsl:otherwise><xsl:value-of select="$AttributeName"/></xsl:otherwise>			</xsl:choose>		</xsl:variable>		<xsl:call-template name="StringAttributeVariable">			<xsl:with-param name="ObjectName" select="../@Name"/>			<xsl:with-param name="ParentId" select="../@ID"/>			<xsl:with-param name="ParentIdType" select="'g'"/>			<xsl:with-param name="Namespace" select="'ns=2'"/>			<xsl:with-param name="AttributeName" select="$AttributeName"/>			<xsl:with-param name="AttributeValue" select="."/>		</xsl:call-template>	</xsl:template>	<!--Hier mÃ¼sste umgestellt werden auf das nÃ¤chste Template von AdditionalInformation, in dem die einzelnen Elemente ausgelesen werden und nicht nur alles als ein Block-->	<xsl:template match="caex:SourceDocumentInformation">		<xsl:variable name="AttributeName">			<xsl:call-template name="NumberedAttributeName"/>		</xsl:variable>		<xsl:call-template name="StringAttributeVariable">			<xsl:with-param name="ObjectName" select="../@Name"/>			<xsl:with-param name="ParentId" select="'CAEXFile'"/>			<xsl:with-param name="ParentIdType" select="'s'"/>			<xsl:with-param name="Namespace" select="'ns=2'"/>			<xsl:with-param name="AttributeName" select="$AttributeName"/>			<xsl:with-param name="AttributeValue" select="."/>		</xsl:call-template>	</xsl:template>	<xsl:template match="caex:CAEXFile/caex:AdditionalInformation">		<xsl:variable name="AttributeName">			<xsl:call-template name="NumberedAttributeName"/>		</xsl:variable>		<xsl:variable name="BrowseName">			<xsl:call-template name="AttributeBrowseName"/>		</xsl:variable>		<!-- Create property -->		<xsl:comment>			<xsl:text>Attribute: </xsl:text>CAEXFile.<xsl:value-of select="$BrowseName"/>		</xsl:comment>		<xsl:call-template name="StringAttributeVariable">			<xsl:with-param name="ObjectName" select="CAEXFile"/>			<xsl:with-param name="ParentId" select="'CAEXFile'"/>			<xsl:with-param name="ParentIdType" select="'s'"/>			<xsl:with-param name="Namespace" select="'ns=2'"/>			<xsl:with-param name="AttributeName" select="$AttributeName"/>			<xsl:with-param name="BrowseName" select="$BrowseName"/>			<xsl:with-param name="AttributeValue" select="."/>				</xsl:call-template>				<!--UAVariable>			<xsl:attribute name="NodeId">				<xsl:value-of select="concat('ns=2;s=CAEXFile_', $AttributeName)"/>			</xsl:attribute>			<xsl:attribute name="BrowseName">				<xsl:value-of select="$BrowseName"/>			</xsl:attribute>			<xsl:attribute name="ParentNodeId">ns=2;s=CAEXFile</xsl:attribute>			<xsl:attribute name="DataType">String</xsl:attribute>			<DisplayName>				<xsl:value-of select="$BrowseName"/>			</DisplayName>			<References>				<Reference ReferenceType="HasTypeDefinition">i=68</Reference>			</References>			<Value>				<xsl:call-template name="AttributeStringValue"/>			</Value>		</UAVariable-->	</xsl:template>	<!-- .........................................................................		Attribute tags of InternalElements and Class definitions	.........................................................................-->	<xsl:template name="GetAttributeParentName">		<xsl:param name="Parent"/>		<xsl:choose>			<xsl:when test="$Parent/@ID!='' and starts-with($Parent/@ID, '{')">				<xsl:value-of select="$Parent/@ID"/>			</xsl:when>			<xsl:when test="$Parent/@ID!=''">				<xsl:value-of select="concat('{', $Parent/@ID, '}')"/>			</xsl:when>			<xsl:when test="name($Parent)='Attribute'">				<xsl:variable name="ParentName">					<xsl:call-template name="GetAttributeParentName">						<xsl:with-param name="Parent" select="$Parent/.."/>					</xsl:call-template>				</xsl:variable>				<xsl:value-of select="concat($ParentName, '_', ../@Name)"/>			</xsl:when>			<xsl:otherwise>				<xsl:value-of select="$Parent/@Name"/>			</xsl:otherwise>		</xsl:choose>	</xsl:template>	<xsl:template match="caex:Attribute">		<xsl:variable name="NsId">			<xsl:call-template name="GetNamespaceId"/>		</xsl:variable>		<!-- Get object variables -->		<xsl:variable name="ObjectId">			<xsl:call-template name="GetAttributeParentName">				<xsl:with-param name="Parent" select=".."/>			</xsl:call-template>		</xsl:variable>		<xsl:variable name="ObjectNodeId">			<xsl:choose>				<xsl:when test="../@ID!=''">g=<xsl:value-of select="$ObjectId"/>				</xsl:when>				<xsl:otherwise>s=<xsl:value-of select="$ObjectId"/>				</xsl:otherwise>			</xsl:choose>		</xsl:variable>		<xsl:variable name="AttributeDataType">			<xsl:value-of select="@AttributeDataType"/>		</xsl:variable>		<xsl:variable name="Datatype">			<xsl:choose>				<xsl:when test="exslt:node-set($DataTypes)/*[@AML=$AttributeDataType]/@OPC!=''">					<xsl:value-of select="exslt:node-set($DataTypes)/*[@AML=$AttributeDataType]/@OPC"/>				</xsl:when>				<xsl:otherwise>					<xsl:value-of select="substring-after($AttributeDataType, ':')"/>				</xsl:otherwise>			</xsl:choose>				</xsl:variable>		<xsl:comment>			<xsl:text>Attribute: </xsl:text>			<xsl:value-of select="../@Name"/>.<xsl:value-of select="@Name"/>		</xsl:comment>		<UAVariable>			<xsl:attribute name="NodeId">				<xsl:value-of select="concat('ns=', $NsId, ';s=',  fn2:remove-space($ObjectId), '_', fn2:remove-space(@Name))"/>			</xsl:attribute>			<xsl:attribute name="BrowseName">				<xsl:text>1:</xsl:text>				<xsl:value-of select="@Name"/>			</xsl:attribute>			<xsl:attribute name="ParentNodeId">				<xsl:value-of select="concat('ns=', $NsId, ';', fn2:remove-space($ObjectNodeId))"/>			</xsl:attribute>			<xsl:attribute name="DataType">				<xsl:value-of select="$Datatype"/>			</xsl:attribute>			<DisplayName>				<xsl:value-of select="@Name"/>			</DisplayName>			<References>				<xsl:comment>Parent: <xsl:value-of select="$ObjectId"/></xsl:comment>				<Reference ReferenceType="HasProperty" IsForward="false">					<xsl:value-of select="concat('ns=', $NsId, ';', $ObjectNodeId)"/>				</Reference>				<xsl:comment>HasTypeDefinition: Property Type</xsl:comment>				<Reference ReferenceType="HasTypeDefinition">i=68</Reference>				<xsl:call-template name="References">					<xsl:with-param name="ObjectName" select="@Name"/>					<xsl:with-param name="ObjectId" select="concat($ObjectId, '_', @Name)"/>					<xsl:with-param name="ObjectIdType" select="'s'"/>					<xsl:with-param name="Namespace" select="$NsId"/>				</xsl:call-template>			</References>			<Value>				<xsl:choose>					<xsl:when test="$Datatype='String' or $Datatype='Boolean' or $Datatype='Int32'">						<xsl:choose>							<xsl:when test="caex:Value!=''">								<xsl:element name="{$Datatype}"  namespace="http://opcfoundation.org/UA/2008/02/Types.xsd">									<xsl:value-of select="caex:Value"/>								</xsl:element>							</xsl:when>							<xsl:when test="caex:DefaultValue!=''">								<xsl:element name="{$Datatype}"  namespace="http://opcfoundation.org/UA/2008/02/Types.xsd">									<xsl:value-of select="caex:DefaultValue"/>								</xsl:element>							</xsl:when>						</xsl:choose>												</xsl:when>					<xsl:otherwise><xsl:value-of select="caex:Value"/></xsl:otherwise>				</xsl:choose>							</Value>			<xsl:if test="caex:Constraint">				<xsl:comment>					<xsl:text>TODO: handle constraint </xsl:text>					<xsl:value-of select="caex:Constraint/@Name"/>				</xsl:comment>			</xsl:if>		</UAVariable>		<xsl:apply-templates select="*"/>	</xsl:template>	<!-- .........................................................................		References to all kind of attributes	.........................................................................-->	<xsl:template name="References">		<xsl:param name="ObjectName"/>		<xsl:param name="ObjectId"/>		<xsl:param name="ObjectIdType"/>		<xsl:param name="Namespace"/>		<xsl:variable name="CompleteNamespace">			<xsl:choose>				<xsl:when test="$Namespace">					<xsl:value-of select="$Namespace"/>				</xsl:when>				<xsl:otherwise>					<xsl:value-of select="'2'"/>				</xsl:otherwise>			</xsl:choose>		</xsl:variable>		<xsl:variable name="CompleteObjectId">			<xsl:choose>				<xsl:when test="$ObjectIdType='g' and starts-with($ObjectId, '{')">					<xsl:value-of select="concat('ns=' , $CompleteNamespace, ';s=', fn2:remove-space($ObjectId), '_')"/>				</xsl:when>				<xsl:when test="$ObjectIdType='g'">					<xsl:value-of select="concat('ns=' , $CompleteNamespace, ';s={', fn2:remove-space($ObjectId), '}_')"/>				</xsl:when>				<xsl:otherwise>					<xsl:value-of select="concat('ns=' , $CompleteNamespace, ';s=', fn2:remove-space($ObjectId), '_')"/>				</xsl:otherwise>			</xsl:choose>		</xsl:variable>		<xsl:if test="@ID">			<!-- Reference to AML-ID property -->			<xsl:comment>AML-ID</xsl:comment>			<Reference ReferenceType="HasProperty">				<xsl:value-of select="concat($CompleteObjectId, 'ID')"/>			</Reference>		</xsl:if>		<!-- Reference to Version property -->		<xsl:if test="Version">			<xsl:comment>Version</xsl:comment>			<Reference ReferenceType="HasProperty">				<xsl:value-of select="concat($CompleteObjectId, 'Version')"/>			</Reference>		</xsl:if>		<!-- References for all Attribute properties -->		<xsl:for-each select="caex:Attribute">			<xsl:comment>				<xsl:text>Attribute: </xsl:text>				<xsl:value-of select="@Name"/>			</xsl:comment>			<Reference ReferenceType="HasProperty">				<xsl:value-of select="concat($CompleteObjectId, fn2:remove-space(@Name))"/>			</Reference>		</xsl:for-each>		<!-- Reference to SupportedRoleClass -->		<xsl:for-each select="caex:SupportedRoleClass">			<!-- Parse SupportedRoleClass -->			<xsl:variable name="RCName" select="substring-before(@RefRoleClassPath,'/')"/>			<xsl:variable name="RCContent">				<xsl:if test="$RCName!= '' and $RCName!= 'AutomationMLBaseRoleClassLib/AutomationMLBaseRole'">					<xsl:call-template name="GetClass">						<xsl:with-param name="path" select="@RefRoleClassPath"/>					</xsl:call-template>				</xsl:if>			</xsl:variable>			<xsl:variable name="LibName" select="ancestor::RoleClassLib[1]/@Name"/>			<!-- Create HasAMLRoleReference -->			<xsl:comment>				<xsl:text>SupportedRoleClass: </xsl:text>				<xsl:value-of select="@RefRoleClassPath"/>			</xsl:comment>			<xsl:variable name="LibNsId">				<xsl:call-template name="GetNamespaceIdByName">					<xsl:with-param name="Namespace" select="$RCName"/>				</xsl:call-template>			</xsl:variable>			<Reference ReferenceType="HasAMLRoleReference">				<xsl:value-of select="fn2:remove-space(concat('ns=', $LibNsId, ';s=', exslt:node-set($RCContent)/RoleClass/@Name))"/>			</Reference>		</xsl:for-each>		<!-- Reference to ExternalInterface objects -->		<xsl:for-each select="caex:ExternalInterface">			<xsl:comment>				<xsl:text>ExternalInterface: </xsl:text>				<xsl:value-of select="@Name"/>			</xsl:comment>			<Reference ReferenceType="HasComponent">				<xsl:value-of select="fn2:remove-space(concat($CompleteObjectId, @Name))"/>			</Reference>		</xsl:for-each>		<!-- Reference to InternalElement objects -->		<xsl:for-each select="caex:InternalElement">			<xsl:comment>				<xsl:text>InternalElement: </xsl:text>				<xsl:value-of select="@Name"/>			</xsl:comment>			<Reference ReferenceType="HasComponent">				<xsl:value-of select="fn2:remove-space(concat($CompleteObjectId, @Name))"/>			</Reference>		</xsl:for-each>	</xsl:template>	<!-- ***************************************************************************  ***  Hierarchical elements********************************************************************************* -->	<!-- Create Collection as parent for InstanceHierarchies and the differnt types of libraries -->	<xsl:template name="HierarchicalElement">		<xsl:param name="Name"/>		<xsl:param name="ChildName"/>		<xsl:comment>			<xsl:value-of select="concat('Collection: CAEXFile.', $Name)"/>		</xsl:comment>		<xsl:if test="*[local-name()=$ChildName]">			<UAObject>				<xsl:attribute name="NodeId">					<xsl:value-of select="concat('ns=2;s=CAEXFile_', fn2:remove-space($Name))"/>				</xsl:attribute>				<xsl:attribute name="BrowseName">					<xsl:value-of select="$Name"/>				</xsl:attribute>				<xsl:attribute name="ParentNodeId">					<xsl:value-of select="'ns=2;s=CAEXFile'"/>				</xsl:attribute>				<DisplayName>					<xsl:value-of select="$Name"/>				</DisplayName>				<References>					<Reference ReferenceType="HasComponent" IsForward="false">ns=2;s=CAEXFile</Reference>					<Reference ReferenceType="HasTypeDefinition">i=61</Reference>					<xsl:for-each select="*[local-name()=$ChildName]">						<xsl:comment>							<xsl:value-of select="concat($ChildName, ': ', @Name)"/>						</xsl:comment>						<Reference ReferenceType="HasComponent">							<xsl:choose>								<xsl:when test="$Name='InstanceHierarchies'">									<xsl:value-of select="concat('ns=2;InstanceHierarchy_', fn2:remove-space(@Name))"/>								</xsl:when>								<xsl:otherwise>									<xsl:variable name="NsId">										<xsl:call-template name="GetNamespaceId"/>									</xsl:variable>									<xsl:value-of select="concat('ns=', $NsId, ';s=', name(.), fn:position())"/>								</xsl:otherwise>							</xsl:choose>						</Reference>					</xsl:for-each>				</References>			</UAObject>		</xsl:if>		<xsl:apply-templates select="node()[local-name()=$ChildName]"/>	</xsl:template>	<!-- .........................................................................		External Interfaces	.........................................................................-->	<xsl:template match="caex:ExternalInterface">		<xsl:variable name="NsId">			<xsl:call-template name="GetNamespaceId"/>		</xsl:variable>		<!-- Get object variables -->		<xsl:variable name="ParentName" select="../@Name"/>		<xsl:variable name="ParentId" select="../@ID"/>		<xsl:variable name="ParentIdString">			<xsl:choose>				<xsl:when test="$ParentId!='' and starts-with($ParentId, '{')">					<xsl:value-of select="../@ID"/>				</xsl:when>				<xsl:when test="$ParentId!=''">					<xsl:value-of select="concat('{', $ParentId, '}')"/>				</xsl:when>				<xsl:otherwise>					<xsl:value-of select="$ParentName"/>				</xsl:otherwise>			</xsl:choose>		</xsl:variable>		<xsl:variable name="ParentNodeId">			<xsl:choose>				<xsl:when test="../@ID!=''">					<xsl:value-of select="fn2:remove-space(concat('ns=', $NsId, ';', 'g=', $ParentIdString))"/>				</xsl:when>				<xsl:otherwise>					<xsl:value-of select="fn2:remove-space(concat('ns=', $NsId, ';', 's=', $ParentIdString))"/>				</xsl:otherwise>			</xsl:choose>		</xsl:variable>		<xsl:variable name="InterfaceName" select="@Name"/>		<xsl:variable name="InterfaceId">		 <xsl:value-of select="fn2:remove-space(concat($ParentIdString, '_', $InterfaceName))"/>		</xsl:variable>		<xsl:variable name="InterfaceNodeId">			<xsl:value-of select="concat('ns=', $NsId, ';s=' , $InterfaceId)"/>		</xsl:variable>		<xsl:comment>			<xsl:text>ExternalInterface: </xsl:text>			<xsl:value-of select="concat($ParentName, '.', $InterfaceName)"/>		</xsl:comment>		<UAObject>			<xsl:attribute name="NodeId">				<xsl:value-of select="$InterfaceNodeId"/>			</xsl:attribute>			<xsl:attribute name="BrowseName">				<xsl:value-of select="@Name"/>			</xsl:attribute>			<xsl:attribute name="ParentNodeId">				<xsl:value-of select="$ParentNodeId"/>			</xsl:attribute>			<!--xsl:attribute name="DataType">String</xsl:attribute-->			<DisplayName>				<xsl:value-of select="@Name"/>			</DisplayName>			<References>				<!--Reference ReferenceType="HasComponent" IsForward="false"></Reference-->				<xsl:comment>TODO: correct TypeDefinition</xsl:comment>				<Reference ReferenceType="HasTypeDefinition">i=68</Reference>				<xsl:call-template name="References">					<xsl:with-param name="ObjectName" select="@Name"/>					<xsl:with-param name="ObjectId" select="@ID"/>					<xsl:with-param name="ObjectIdType" select="'g'"/>					<xsl:with-param name="Namespace" select="$NsId"/>				</xsl:call-template>				<xsl:for-each select="$InternalLinks/ua:InternalLinks/ua:InternalLink[@InterfaceSideA=$InterfaceName and @ParentSideA=$ParentId]">					<xsl:comment>TODO: handle InternalLinks that use the name of the parent instead of the ID or already contain '{}'.</xsl:comment>					<xsl:comment><xsl:value-of select="concat('InternalLink: ', @Name)"/></xsl:comment>					<Reference ReferenceType="HasAMLInternalLink">						<xsl:value-of select="fn2:remove-space(concat('ns=', $NsId, ';', 's={', @ParentSideB,'}_',@InterfaceSideB))"/>					</Reference>				</xsl:for-each>				<xsl:for-each select="$InternalLinks/ua:InternalLinks/ua:InternalLink[@InterfaceSideB=$InterfaceName and @ParentSideB=$ParentId]">					<xsl:comment>TODO: handle InternalLinks that use the name of the parent instead of the ID or already contain '{}'.</xsl:comment>					<xsl:comment><xsl:value-of select="concat('InternalLink: ', @Name)"/></xsl:comment>					<Reference ReferenceType="HasAMLInternalLink" IsForward="false">						<xsl:value-of select="fn2:remove-space(concat('ns=', $NsId, ';', 's={',@ParentSideA,'}_',@InterfaceSideA))"/>					</Reference>				</xsl:for-each>			</References>		</UAObject>		<!-- Create referred UAVariables and UAObjects -->		<xsl:apply-templates select="@ID|node()"/>	</xsl:template>	<!-- .........................................................................		InternalElements	.........................................................................-->	<xsl:template match="caex:InternalElement">		<xsl:variable name="NsId">			<xsl:call-template name="GetNamespaceId"/>		</xsl:variable>		<!-- Parse SystemUnitClass -->		<xsl:variable name="UCName" select="substring-before(@RefBaseSystemUnitPath,'/')"/>		<xsl:variable name="UCContent">			<xsl:if test="$UCName!= '' and $UCName!= 'AutomationMLBaseRoleClassLib/AutomationMLBaseRole'">				<xsl:call-template name="GetClass">					<xsl:with-param name="path" select="@RefBaseSystemUnitPath"/>				</xsl:call-template>			</xsl:if>		</xsl:variable>		<!-- Create UAObject -->		<UAObject>			<xsl:attribute name="NodeId">				<xsl:value-of select="concat('ns=', $NsId, ';g={', @ID, '}')"/>			</xsl:attribute>			<xsl:attribute name="BrowseName">				<xsl:value-of select="@Name"/>			</xsl:attribute>			<DisplayName>				<xsl:value-of select="@Name"/>			</DisplayName>			<xsl:if test="Description">				<Description>					<xsl:value-of select="caex:Description"/>				</Description>			</xsl:if>			<References>				<xsl:if test="exslt:node-set($UCContent)/*!=''">					<!-- Reference to class definition -->					<xsl:comment>						<xsl:text>Class definition</xsl:text>					</xsl:comment>					<Reference ReferenceType="HasTypeDefinition">						<xsl:value-of select="concat('ns=', $UCName, ';s=', fn2:remove-space(exslt:node-set($UCContent)/caex:SystemUnitClass/@Name))"/>					</Reference>				</xsl:if>				<xsl:call-template name="References">					<xsl:with-param name="ObjectName" select="@Name"/>					<xsl:with-param name="ObjectId" select="@ID"/>					<xsl:with-param name="ObjectIdType" select="'g'"/>					<xsl:with-param name="Namespace" select="$NsId"/>				</xsl:call-template>			</References>		</UAObject>		<!-- Create referred UAVariables and UAObjects -->		<xsl:apply-templates select="@ID|node()"/>	</xsl:template></xsl:stylesheet>