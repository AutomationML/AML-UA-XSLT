<?xml version="1.0" encoding="UTF-8"?><xsl:stylesheet version="2.0" xmlns:fn2="http://whatever" xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.dke.de/CAEX" xmlns:caex="http://www.dke.de/CAEX" xmlns:exslt="http://exslt.org/common" xmlns="http://opcfoundation.org/UA/2011/03/UANodeSet.xsd" xmlns:ua="http://opcfoundation.org/UA/2011/03/UANodeSet.xsd" xmlns:uax="http://opcfoundation.org/UA/2008/02/Types.xsd" exclude-result-prefixes="#default caex xsi xsl exslt fn ua fn2">	<!-- ******************************************************************* Helper**************************************************************** -->	<!-- if there is no xmlns given (e.g. V2.15 examples we need xsi:noNamespaceLocation -->	<xsl:output method="xml" version="1.0" encoding="UTF-8" indent="yes" omit-xml-declaration="yes" cdata-section-elements="String"/>	<xsl:variable name="document-root" select="/"/>	<xsl:function name="exslt:node-set">		<xsl:param name="rtf"/>		<xsl:sequence select="$rtf"/>	</xsl:function>	<xsl:function name="fn2:remove-space">		<xsl:param name="value"/>		<xsl:value-of select="replace($value, ' ', '')"/>	</xsl:function>	<!-- Does not work with MSXSL -->	<!--xsl:function name="exslt:ends-with">		<xsl:param name="target"/>		<xsl:param name="suffix"/>		<xsl:sequence select="$suffix = substring($target, string-length($target) - string-length($suffix) + 1)"/>	</xsl:function-->	<!-- ******************************************************************* Translate differnt versions of AML to a common namespace**************************************************************** -->	<!-- 		translate V2 files to V3 namespace 	    this allows us to use the same translation rules for AML V2 and V3 	-->	<xsl:template match="CAEXFile">		<xsl:variable name="withNS">			<xsl:element name="{name(.)}" namespace="http://www.dke.de/CAEX">				<xsl:copy-of select="@*"/>				<xsl:apply-templates mode="copy-to-new-ns"/>			</xsl:element>		</xsl:variable>		<xsl:apply-templates select="$withNS"/>	</xsl:template>	<xsl:template mode="copy-to-new-ns" match="*">		<xsl:element name="{name(.)}" namespace="http://www.dke.de/CAEX">			<xsl:copy-of select="@*"/>			<xsl:apply-templates mode="copy-to-new-ns"/>		</xsl:element>	</xsl:template>	<xsl:template match="@*"/>	<!-- ******************************************************************* Prepare translation**************************************************************** -->	<!-- Parsing of SystemUnitClassLib, InterfaceClassLib, RoleClassLib, AttributeTypeLib-->	<xsl:include href="LibraryParsing.xslt"/>	<xsl:include href="DatatypeTranslation.xslt"/>	<!-- Translation of SystemUnitClassLib, InterfaceClassLib, RoleClassLib, AttributeTypeLib-->	<xsl:include href="LibraryTranslation.xslt"/>	<!-- Collect all namespaces -->	<xsl:variable name="NamespaceUris">		<NamespaceUris>			<Uri>http://opcfoundation.org/UA/AML/</Uri>			<Uri>http://opcfoundation.org/UA/AML/MyInstances</Uri>			<!-- use local-name() here because namespace is not equalized at this point, yet -->			<xsl:for-each select="*[local-name()='CAEXFile']/*[local-name()='InterfaceClassLib' or local-name()='RoleClassLib' or local-name()='SystemUnitClassLib' or local-name()='AttributeTypeLib']">				<Uri>					<xsl:value-of select="concat('http://opcfoundation.org/UA/AML/', @Name)"/>				</Uri>			</xsl:for-each>		</NamespaceUris>	</xsl:variable>	<xsl:variable name="Models">		<xsl:variable name="today" select="fn:current-date()"/>		<xsl:variable name="baseModels">			<RequiredModel ModelUri="http://opcfoundation.org/UA/" Version="1.04.3" PublicationDate="2019-09-09T00:00:00Z"/>			<RequiredModel ModelUri="http://opcfoundation.org/UA/AML/" Version="1.0.1" PublicationDate="2019-09-09T00:00:00Z"/>		</xsl:variable>		<Models>			<xsl:for-each select="*[local-name()='CAEXFile']/*[local-name()='InterfaceClassLib' or local-name()='RoleClassLib' or local-name()='SystemUnitClassLib' or local-name()='AttributeTypeLib']">				<Model>					<xsl:attribute name="ModelUri" select="concat('http://opcfoundation.org/UA/AML/', @Name)"/>					<xsl:attribute name="Version" select="caex:Version"/>					<xsl:attribute name="PublicationDate" select="format-dateTime(fn:current-dateTime(),'[Y0001]-[M01]-[D01]T[h01]:[m01]:[s01]Z')"/>					<xsl:copy-of select="$baseModels"/>				</Model>			</xsl:for-each>			<Model ModelUri="http://opcfoundation.org/UA/AML/MyInstances" Version="0.0.0">				<xsl:attribute name="PublicationDate" select="format-dateTime(fn:current-dateTime(),'[Y0001]-[M01]-[D01]T[h01]:[m01]:[s01]Z')"/>				<xsl:copy-of select="$baseModels"/>				<xsl:for-each select="*[local-name()='CAEXFile']/*[local-name()='InterfaceClassLib' or local-name()='RoleClassLib' or local-name()='SystemUnitClassLib' or local-name()='AttributeTypeLib']">					<RequiredModel>						<xsl:attribute name="ModelUri" select="concat('http://opcfoundation.org/UA/AML/', @Name)"/>						<xsl:choose>							<xsl:when test="caex:Version='0'">								<xsl:attribute name="Version" select="'0.0.0'"/>							</xsl:when>							<xsl:when test="caex:Version=''">								<xsl:attribute name="Version" select="'0.0.0'"/>							</xsl:when>							<xsl:otherwise>								<xsl:attribute name="Version" select="caex:Version"/>							</xsl:otherwise>						</xsl:choose>						<xsl:attribute name="PublicationDate" select="format-dateTime(fn:current-dateTime(),'[Y0001]-[M01]-[D01]T[h01]:[m01]:[s01]Z')"/>					</RequiredModel>				</xsl:for-each>			</Model>		</Models>	</xsl:variable>	<!-- Collect all InternalLinks and equalize namespace-->	<xsl:variable name="InternalLinks">		<InternalLinks>			<xsl:for-each select="//*[local-name()='InternalLink']">				<InternalLink>					<xsl:copy-of select="@Name"/>					<xsl:attribute name="ParentSideA" select="substring-before(@RefPartnerSideA,':')"/>					<xsl:attribute name="InterfaceSideA" select="substring-after(@RefPartnerSideA,':')"/>					<xsl:attribute name="ParentSideB" select="substring-before(@RefPartnerSideB,':')"/>					<xsl:attribute name="InterfaceSideB" select="substring-after(@RefPartnerSideB,':')"/>				</InternalLink>			</xsl:for-each>		</InternalLinks>	</xsl:variable>	<!-- ***************************************************************************  ***  Skeleton********************************************************************************* -->	<!-- .........................................................................		CAEXFile: Create Skeleton	.........................................................................-->	<xsl:template match="caex:CAEXFile">		<!--Test><xsl:copy-of select="$InternalLinks"/></Test-->		<UANodeSet xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:uax="http://opcfoundation.org/UA/2008/02/Types.xsd" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="http://opcfoundation.org/UA/2011/03/UANodeSet.xsd">			<xsl:comment>			Documentation			===============			To support both CAEX V2.15 and CAEX V3.0 we add the namespace to CAEX V2.15 before translation. 			UANodeSet			=============			TODOs:				- Do we need aliases?? 					- to be clarified with UA -> Miriam				    - only used ones or standard template set of aliases					- purpose? drawback								- InternalLinks are not translated, yet.				- Missing translation for UtcTime/DateTime				- How to use Table 14 in DataTypeMapping v5.0? -> Add mapping to translation table				- no HasTypeDefinition available if there was no SystemUnitClass (see "BPR_005E_ExternalDataReference_Examples_Jul2016.aml")				- use correct HasTypeDefinition				- are spaces allowed in NodeId string as part if the ID? 				    - to be clarified with AML if spaces are allowed (Part 1) -> Miriam					- Example in AR APC all Classes AutomationProjectConfigurationRoleClassLib/DeviceItem Attributes					- necessary for nodeID (BrowseName keeps space), thus deleted				- are '{GUID}' and 'GUID' equal? -> will be handled as equivalent				- InterfaceClasses have no specific UA "base structure", but are also of type ObjectType -> how to distinguish between SUC and IC				- AdditionalInformation is handled as blackbox (no ID)				- AdditionalInformation AutomationMLVersion				- from UA to AML: what if we have no "file name" in UA XML (Nodeset has no name) (which element to use as filename)				- XSL + script for generation of MD5 hash								- How to understand the hierarchical elements (incl. HasTypeDefinition)?				- support AttributeTypeLib (CAEX V3.0)				- fix model version for RequiredModels -> is this correct?			</xsl:comment>			<xsl:copy-of select="$NamespaceUris"/>			<xsl:copy-of select="$Models"/>			<Aliases>				<Alias Alias="Boolean">i=1</Alias>				<Alias Alias="SByte">i=2</Alias>				<Alias Alias="Byte">i=3</Alias>				<Alias Alias="Int16">i=4</Alias>				<Alias Alias="UInt16">i=5</Alias>				<Alias Alias="Int32">i=6</Alias>				<Alias Alias="UInt32">i=7</Alias>				<Alias Alias="Int64">i=8</Alias>				<Alias Alias="UInt64">i=9</Alias>				<Alias Alias="Float">i=10</Alias>				<Alias Alias="Double">i=11</Alias>				<Alias Alias="DateTime">i=13</Alias>				<Alias Alias="String">i=12</Alias>				<Alias Alias="ByteString">i=15</Alias>				<Alias Alias="Guid">i=14</Alias>				<Alias Alias="XmlElement">i=16</Alias>				<Alias Alias="NodeId">i=17</Alias>				<Alias Alias="ExpandedNodeId">i=18</Alias>				<Alias Alias="QualifiedName">i=20</Alias>				<Alias Alias="LocalizedText">i=21</Alias>				<Alias Alias="StatusCode">i=19</Alias>				<Alias Alias="Structure">i=22</Alias>				<Alias Alias="Number">i=26</Alias>				<Alias Alias="Integer">i=27</Alias>				<Alias Alias="UInteger">i=28</Alias>				<Alias Alias="HasComponent">i=47</Alias>				<Alias Alias="HasProperty">i=46</Alias>				<Alias Alias="Organizes">i=35</Alias>				<Alias Alias="HasEventSource">i=36</Alias>				<Alias Alias="HasNotifier">i=48</Alias>				<Alias Alias="HasSubtype">i=45</Alias>				<Alias Alias="HasTypeDefinition">i=40</Alias>				<Alias Alias="HasModellingRule">i=37</Alias>				<Alias Alias="HasEncoding">i=38</Alias>				<Alias Alias="HasDescription">i=39</Alias>				<Alias Alias="Duration">i=290</Alias>				<Alias Alias="HasAMLInternalLink">ns=1;i=4002</Alias>				<xsl:comment>To avoid double listing due to HasComponent and HasSubtype we invented an AML specific HasComponentVersion</xsl:comment>				<Alias Alias="HasAMLClassComponent">ns=1;i=4002</Alias>				<Alias Alias="HasAMLRoleReference">ns=1;i=4001</Alias>				<Alias Alias="CAEXObjectType">ns=1;i=1001</Alias>			</Aliases>			<xsl:comment>			CAEXFile			===============			TODOs:				- is this the correct translation (AMLFile = Object)? -> currently yes				- do we really need InstanceHierarchies, InterfaceClassLibs and other organizing elements? --> variable in xslt to include or not, flag in xslt if things were included				- How to model ExternalReferences?					- Include external libraries or include parts of the models from an external file (e.g. in case of big models)					- Option 1: merge external references into AML file before applying XSL transformation (no external references in AML file)					- Option 2: each externally referenced AML model is translated into a OPC UA namespace named with the ExternalReference alias name  each external reference you find inside the AML model is like internal AML reference, but references the other namespace					- Option 3: keep ExternalReferences as property of CAEXFile object; in case of an external reference inside the model, no linking to another OPC UA node is possible, but information is persisted					- Preferences: 2-1-3 or 1-2-3/2-1-3 					- report in AML TAC				- How to handle DefaultValues of attributes?			</xsl:comment>			<UAObject>				<xsl:attribute name="NodeId">					<xsl:call-template name="FormatRef">						<xsl:with-param name="ObjectId" select="'CAEXFile'"/>					</xsl:call-template>				</xsl:attribute>				<xsl:attribute name="BrowseName">					<xsl:value-of select="concat('2:',@FileName)"/>				</xsl:attribute>				<DisplayName>					<xsl:value-of select="@FileName"/>				</DisplayName>				<Documentation>					<xsl:value-of select="caex:Description"/>				</Documentation>				<References>					<xsl:comment>Type definition: CAEXFileType</xsl:comment>					<Reference ReferenceType="HasTypeDefinition">ns=1;i=1005</Reference>					<xsl:if test="@FileName">						<xsl:comment>FileName</xsl:comment>						<Reference ReferenceType="HasProperty">							<xsl:call-template name="FormatRef">								<xsl:with-param name="ObjectId" select="'CAEXFile_FileName'"/>							</xsl:call-template>						</Reference>					</xsl:if>					<xsl:if test="@SchemaVersion">						<xsl:comment>SchemaVersion</xsl:comment>						<Reference ReferenceType="HasProperty">							<xsl:call-template name="FormatRef">								<xsl:with-param name="ObjectId" select="'CAEXFile_SchemaVersion'"/>							</xsl:call-template>						</Reference>					</xsl:if>					<xsl:if test="caex:SuperiorStandardVersion">						<xsl:comment>SuperiorStandardVersion</xsl:comment>						<Reference ReferenceType="HasProperty">							<xsl:call-template name="FormatRef">								<xsl:with-param name="ObjectId" select="'CAEXFile_SuperiorStandardVersion'"/>							</xsl:call-template>						</Reference>					</xsl:if>					<xsl:comment>InstanceHierarchy</xsl:comment>					<xsl:if test="//caex:InstanceHierarchy">						<Reference ReferenceType="HasComponent">							<xsl:call-template name="FormatRef">								<xsl:with-param name="ObjectId" select="'CAEXFile_InstanceHierarchies'"/>							</xsl:call-template>						</Reference>					</xsl:if>					<xsl:comment>Libraries</xsl:comment>					<xsl:if test="//caex:InterfaceClassLib">						<Reference ReferenceType="HasComponent">							<xsl:call-template name="FormatRef">								<xsl:with-param name="ObjectId" select="'CAEXFile_InterfaceClassLibs'"/>							</xsl:call-template>						</Reference>					</xsl:if>					<xsl:if test="//caex:RoleClassLib">						<Reference ReferenceType="HasComponent">							<xsl:call-template name="FormatRef">								<xsl:with-param name="ObjectId" select="'CAEXFile_RoleClassLibs'"/>							</xsl:call-template>						</Reference>					</xsl:if>					<xsl:if test="//caex:SystemUnitClassLib">						<Reference ReferenceType="HasComponent">							<xsl:call-template name="FormatRef">								<xsl:with-param name="ObjectId" select="'CAEXFile_SystemUnitClassLibs'"/>							</xsl:call-template>						</Reference>					</xsl:if>					<xsl:if test="//caex:AttributeTypeLib">						<Reference ReferenceType="HasComponent">							<xsl:call-template name="FormatRef">								<xsl:with-param name="ObjectId" select="'CAEXFile_AttributeTypeLibs'"/>							</xsl:call-template>						</Reference>					</xsl:if>					<xsl:for-each select="caex:AdditionalInformation">						<xsl:variable name="AttributeName">							<xsl:call-template name="NumberedAttributeName"/>						</xsl:variable>						<xsl:variable name="BrowseName">							<xsl:call-template name="AttributeBrowseName"/>						</xsl:variable>						<xsl:comment>							<xsl:value-of select="concat('AdditionalInformation: ', $BrowseName)"/>						</xsl:comment>						<Reference ReferenceType="HasProperty">							<xsl:call-template name="FormatRef">								<xsl:with-param name="ObjectId" select="concat('CAEXFile_', $AttributeName)"/>							</xsl:call-template>						</Reference>					</xsl:for-each>					<xsl:for-each select="caex:SourceDocumentInformation">						<xsl:variable name="AttributeName">							<xsl:call-template name="NumberedAttributeName"/>						</xsl:variable>						<xsl:comment>							<xsl:value-of select="concat('SourceDocumentInformation: ', $AttributeName)"/>						</xsl:comment>						<Reference ReferenceType="HasProperty">							<xsl:call-template name="FormatRef">								<xsl:with-param name="ObjectId" select="concat('CAEXFile_', $AttributeName)"/>							</xsl:call-template>						</Reference>					</xsl:for-each>					<Reference ReferenceType="Organizes" IsForward="false">ns=1;i=5006</Reference>				</References>			</UAObject>			<xsl:apply-templates select="@FileName"/>			<xsl:apply-templates select="@SchemaVersion"/>			<xsl:apply-templates select="./caex:SuperiorStandardVersion"/>			<xsl:comment>			AdditionalInformation			===============			TODOs:				- do we need an extra UAObjectType for additional information? -> no use content of value as marker			    - which version (1. or 2.) is the correct translation of an AdditionalInformation?			</xsl:comment>			<xsl:apply-templates select="./caex:AdditionalInformation"/>			<xsl:apply-templates select="./caex:SourceDocumentInformation"/>			<xsl:comment>			InstanceHierarchies			===============			TODOs:				- do we need a InstanceHierarchies node? What was the result of the discussion? -> variable in xslt to include or not, flag in xslt if things were included			    - Complete References				- Do we need BackwardReferences here?				- Test child of AutomationMLBaseRole/UABaseObjectType				- currently only type definition from Libraries are supported -> support HasTypeDefinition from current namespace			</xsl:comment>			<xsl:call-template name="HierarchicalElement">				<xsl:with-param name="Name" select="'InstanceHierarchies'"/>				<xsl:with-param name="ChildName" select="'InstanceHierarchy'"/>			</xsl:call-template>			<xsl:comment>			InterfaceClassLibs			===============			TODOs:				- do we need a InterfaceClassLibs node? What was the result of the discussion? -> variable in xslt to include or not, flag in xslt if things were included			</xsl:comment>			<xsl:call-template name="HierarchicalElement">				<xsl:with-param name="Name" select="'InterfaceClassLibs'"/>				<xsl:with-param name="ChildName" select="'InterfaceClassLib'"/>			</xsl:call-template>			<xsl:comment>			RoleClassLibs			===============			TODOs:				- ...			</xsl:comment>			<xsl:call-template name="HierarchicalElement">				<xsl:with-param name="Name" select="'RoleClassLibs'"/>				<xsl:with-param name="ChildName" select="'RoleClassLib'"/>			</xsl:call-template>			<xsl:comment>			SystemUnitClassLibs			===============			TODOs:				- check all inner elements, e.g. attributes, etc.			</xsl:comment>			<xsl:call-template name="HierarchicalElement">				<xsl:with-param name="Name" select="'SystemUnitClassLibs'"/>				<xsl:with-param name="ChildName" select="'SystemUnitClassLib'"/>			</xsl:call-template>			<xsl:comment>			AttributeTypeLibs			===============			TODOs:				- check all inner elements, e.g. attributes, etc.				- is this a proper translation?				- how are the AttributeTypes used? - Instances			</xsl:comment>			<xsl:call-template name="HierarchicalElement">				<xsl:with-param name="Name" select="'AttributeTypeLibs'"/>				<xsl:with-param name="ChildName" select="'AttributeTypeLib'"/>			</xsl:call-template>		</UANodeSet>	</xsl:template>	<!-- *************************************************************************** *** InstanceHierarchy***************************************************************************-->	<xsl:template match="caex:InstanceHierarchy">		<xsl:comment>			<xsl:value-of select="concat('InstanceHierarchy: ', @Name)"/>		</xsl:comment>		<UAObject>			<xsl:attribute name="NodeId">				<xsl:call-template name="FormatRef">					<xsl:with-param name="ObjectId" select="concat('InstanceHierarchy_', @Name)"/>				</xsl:call-template>			</xsl:attribute>			<xsl:attribute name="BrowseName">				<xsl:value-of select="concat('2:',@Name)"/>			</xsl:attribute>			<DisplayName>				<xsl:value-of select="@Name"/>			</DisplayName>			<Documentation>				<xsl:value-of select="caex:Description"/>			</Documentation>			<References>				<Reference ReferenceType="HasTypeDefinition">i=61</Reference>				<Reference ReferenceType="Organizes" IsForward="false">ns=1;i=5005</Reference>				<xsl:comment>Backward reference to CAEX InstanceHierarchies</xsl:comment>				<Reference ReferenceType="HasComponent" IsForward="false">					<xsl:call-template name="FormatRef">						<xsl:with-param name="ObjectId" select="'CAEXFile_InstanceHierarchies'"/>					</xsl:call-template>				</Reference>				<xsl:for-each select="caex:InternalElement">					<xsl:comment>						<xsl:value-of select="concat('InternalElement: ', @Name)"/>					</xsl:comment>					<Reference ReferenceType="HasComponent">						<xsl:call-template name="FormatRef">							<xsl:with-param name="ObjectId" select="@ID"/>						</xsl:call-template>					</Reference>				</xsl:for-each>			</References>		</UAObject>		<xsl:apply-templates select="node()"/>	</xsl:template>	<!-- ***************************************************************************  ***  Attributes********************************************************************************* -->	<!-- .........................................................................		Helper to translate attributes and values	.........................................................................-->	<xsl:template name="NumberedAttributeName">		<xsl:choose>			<xsl:when test="position()=1">				<xsl:value-of select="fn2:remove-space(name(.))"/>			</xsl:when>			<xsl:otherwise>				<xsl:value-of select="concat(fn2:remove-space(name(.)),'_', position())"/>			</xsl:otherwise>		</xsl:choose>	</xsl:template>	<xsl:template name="AttributeBrowseName">		<xsl:variable name="AttributeName">			<xsl:call-template name="NumberedAttributeName"/>		</xsl:variable>		<xsl:choose>			<xsl:when test="name(*[1])!=''">				<xsl:value-of select="name(*[1])"/>			</xsl:when>			<xsl:when test="name(@*[1])!=''">				<xsl:value-of select="name(@*[1])"/>			</xsl:when>			<xsl:otherwise>				<xsl:value-of select="$AttributeName"/>			</xsl:otherwise>		</xsl:choose>	</xsl:template>	<xsl:template name="AttributeVariable">		<xsl:param name="ObjectName"/>		<xsl:param name="Parent"/>		<xsl:param name="ParentId"/>		<!-- overrides Parent -->		<xsl:param name="Namespace"/>		<xsl:param name="AttributeName"/>		<xsl:param name="BrowseName" select="$AttributeName"/>		<xsl:param name="AttributeValue"/>		<xsl:variable name="ParentId_">			<xsl:choose>				<xsl:when test="$ParentId">					<xsl:value-of select="$ParentId"/>				</xsl:when>				<xsl:otherwise>					<xsl:call-template name="GetObjectName">						<xsl:with-param name="Object" select="$Parent"/>					</xsl:call-template>				</xsl:otherwise>			</xsl:choose>		</xsl:variable>		<!-- Create property -->		<xsl:comment>			<xsl:text>Attribute: </xsl:text>			<xsl:value-of select="$ObjectName"/>.<xsl:value-of select="$BrowseName"/>		</xsl:comment>		<UAVariable>			<xsl:attribute name="NodeId">				<xsl:call-template name="FormatRef">					<xsl:with-param name="ObjectId" select="concat($ParentId_, '_', $AttributeName)"/>					<xsl:with-param name="Namespace" select="$Namespace"/>				</xsl:call-template>			</xsl:attribute>			<xsl:attribute name="BrowseName">				<xsl:choose>					<xsl:when test="$Namespace=''">						<xsl:value-of select="$BrowseName"/>					</xsl:when>					<xsl:otherwise>						<xsl:value-of select="concat(fn:substring-after($Namespace, '='), ':', $BrowseName)"/>					</xsl:otherwise>				</xsl:choose>			</xsl:attribute>			<xsl:attribute name="ParentNodeId">				<xsl:call-template name="FormatRef">					<xsl:with-param name="ObjectId" select="$ParentId_"/>					<xsl:with-param name="Namespace" select="$Namespace"/>				</xsl:call-template>			</xsl:attribute>			<xsl:attribute name="DataType">String</xsl:attribute>			<DisplayName>				<xsl:value-of select="$BrowseName"/>			</DisplayName>			<References>				<Reference ReferenceType="HasTypeDefinition">i=68</Reference>			</References>			<Value>				<xsl:copy-of select="$AttributeValue"/>			</Value>		</UAVariable>	</xsl:template>	<xsl:template name="StringAttributeVariable">		<xsl:param name="ObjectName"/>		<xsl:param name="Parent"/>		<xsl:param name="ParentId"/>		<xsl:param name="Namespace"/>		<xsl:param name="AttributeName"/>		<xsl:param name="BrowseName" select="$AttributeName"/>		<xsl:param name="AttributeValue"/>		<xsl:variable name="UnescapedAttribute">			<xsl:call-template name="AttributeVariable">				<xsl:with-param name="ObjectName" select="$ObjectName"/>				<xsl:with-param name="Parent" select="$Parent"/>				<xsl:with-param name="ParentId" select="$ParentId"/>				<xsl:with-param name="Namespace" select="$Namespace"/>				<xsl:with-param name="AttributeName" select="$AttributeName"/>				<xsl:with-param name="BrowseName" select="$BrowseName"/>				<xsl:with-param name="AttributeValue">					<!-- use copy-of to allow XML elements as input (e.g. for AdditionalInformation) -->					<xsl:copy-of select="$AttributeValue"/>				</xsl:with-param>			</xsl:call-template>		</xsl:variable>		<!-- Add CDATA if necessary -->		<xsl:for-each select="exslt:node-set($UnescapedAttribute)/*">			<xsl:copy>				<xsl:copy-of select="@*"/>				<xsl:copy-of select="*[name()!='Value']"/>				<Value>					<uax:String>						<xsl:choose>							<xsl:when test="*[name()='Value']/*[1]">								<xsl:value-of disable-output-escaping="yes">&lt;![CDATA[</xsl:value-of>								<xsl:copy-of select="*[name()='Value']/*[1]"/>								<xsl:value-of disable-output-escaping="yes">]]&gt;</xsl:value-of>							</xsl:when>							<xsl:otherwise>								<xsl:value-of select="*[name()='Value']"/>							</xsl:otherwise>						</xsl:choose>					</uax:String>				</Value>			</xsl:copy>		</xsl:for-each>	</xsl:template>	<!-- .........................................................................	Specific attributes of InternalElements and Class definitions	.........................................................................-->	<xsl:template match="@FileName">		<xsl:variable name="NsId">			<xsl:call-template name="GetNamespaceId"/>		</xsl:variable>		<!-- Create FileName property -->		<xsl:call-template name="StringAttributeVariable">			<xsl:with-param name="ObjectName" select="'CAEXFile'"/>			<xsl:with-param name="ParentId" select="'CAEXFile'"/>			<xsl:with-param name="Namespace" select="$NsId"/>			<xsl:with-param name="AttributeName" select="'FileName'"/>			<xsl:with-param name="AttributeValue">				<xsl:value-of select="."/>			</xsl:with-param>		</xsl:call-template>	</xsl:template>	<xsl:template match="@SchemaVersion">		<xsl:variable name="NsId">			<xsl:call-template name="GetNamespaceId"/>		</xsl:variable>		<!-- Create SchemaVersion property -->		<xsl:call-template name="StringAttributeVariable">			<xsl:with-param name="ObjectName" select="'CAEXFile'"/>			<xsl:with-param name="ParentId" select="'CAEXFile'"/>			<xsl:with-param name="Namespace" select="$NsId"/>			<xsl:with-param name="AttributeName" select="'SchemaVersion'"/>			<xsl:with-param name="AttributeValue">				<xsl:value-of select="."/>			</xsl:with-param>		</xsl:call-template>	</xsl:template>	<xsl:template match="@ID">		<xsl:variable name="NsId">			<xsl:call-template name="GetNamespaceId"/>		</xsl:variable>		<!-- Create AML-ID property -->		<xsl:call-template name="StringAttributeVariable">			<xsl:with-param name="ObjectName" select="../@Name"/>			<xsl:with-param name="Parent" select="parent::node()"/>			<xsl:with-param name="Namespace" select="$NsId"/>			<xsl:with-param name="AttributeName" select="'ID'"/>			<xsl:with-param name="AttributeValue">				<xsl:choose>					<xsl:when test="starts-with(../@ID, '{')">						<xsl:value-of select="../@ID"/>					</xsl:when>					<xsl:otherwise>						<xsl:value-of select="concat('{', ../@ID, '}')"/>					</xsl:otherwise>				</xsl:choose>			</xsl:with-param>		</xsl:call-template>	</xsl:template>	<xsl:template match="caex:SuperiorStandardVersion">		<xsl:variable name="NsId">			<xsl:call-template name="GetNamespaceId"/>		</xsl:variable>		<!-- Create SuperiorStandardVersion property -->		<xsl:call-template name="StringAttributeVariable">			<xsl:with-param name="ObjectName" select="'CAEXFile'"/>			<xsl:with-param name="ParentId" select="'CAEXFile'"/>			<xsl:with-param name="Namespace" select="$NsId"/>			<xsl:with-param name="AttributeName" select="'SuperiorStandardVersion'"/>			<xsl:with-param name="AttributeValue">				<xsl:value-of select="."/>			</xsl:with-param>		</xsl:call-template>	</xsl:template>	<xsl:template match="caex:Version">		<xsl:variable name="NsId">			<xsl:call-template name="GetNamespaceId"/>		</xsl:variable>		<xsl:choose>			<xsl:when test="name(..)='InterfaceClassLib' or name(..)='RoleClassLib' or name(..)='SystemUnitClassLib'  or name(..)='AttributeTypeLib'">				<xsl:variable name="LibType">					<xsl:value-of select="name(..)"/>				</xsl:variable>				<xsl:variable name="LibId">					<xsl:value-of select="fn2:remove-space(name(..))"/>				</xsl:variable>				<xsl:call-template name="StringAttributeVariable">					<xsl:with-param name="ObjectName" select="../@Name"/>					<xsl:with-param name="ParentId" select="$LibId"/>					<xsl:with-param name="Namespace" select="$NsId"/>					<xsl:with-param name="AttributeName" select="'Version'"/>					<xsl:with-param name="AttributeValue" select="text()"/>				</xsl:call-template>			</xsl:when>			<xsl:when test="name(..)='InstanceHierarchy'">				<xsl:call-template name="StringAttributeVariable">					<xsl:with-param name="ObjectName" select="../@Name"/>					<xsl:with-param name="ParentId" select="concat('InstanceHierarchy_', ../@Name)"/>					<xsl:with-param name="Namespace" select="'2'"/>					<xsl:with-param name="AttributeName" select="'Version'"/>					<xsl:with-param name="AttributeValue" select="text()"/>				</xsl:call-template>			</xsl:when>			<xsl:otherwise>				<xsl:call-template name="StringAttributeVariable">					<xsl:with-param name="ObjectName" select="../@Name"/>					<xsl:with-param name="Parent" select="parent::node()"/>					<xsl:with-param name="Namespace" select="'2'"/>					<xsl:with-param name="AttributeName" select="'Version'"/>					<xsl:with-param name="AttributeValue" select="text()"/>				</xsl:call-template>			</xsl:otherwise>		</xsl:choose>	</xsl:template>	<xsl:template match="caex:Copyright">		<xsl:variable name="NsId">			<xsl:call-template name="GetNamespaceId"/>		</xsl:variable>		<xsl:call-template name="StringAttributeVariable">			<xsl:with-param name="ObjectName" select="../@Name"/>			<xsl:with-param name="Parent" select="parent::node()"/>			<xsl:with-param name="Namespace" select="$NsId"/>			<xsl:with-param name="AttributeName" select="'Copyright'"/>			<xsl:with-param name="AttributeValue">				<xsl:copy-of select="."/>			</xsl:with-param>		</xsl:call-template>	</xsl:template>	<xsl:template match="*[name()!='CAEXFile']/caex:AdditionalInformation">		<xsl:variable name="AttributeName">			<xsl:call-template name="NumberedAttributeName"/>		</xsl:variable>		<xsl:variable name="BrowseName">			<xsl:choose>				<xsl:when test="@*[1]">					<xsl:value-of select="name(@*[1])"/>				</xsl:when>				<xsl:when test="*[1]">					<xsl:value-of select="name(*[1])"/>				</xsl:when>				<xsl:otherwise>					<xsl:value-of select="$AttributeName"/>				</xsl:otherwise>			</xsl:choose>		</xsl:variable>		<xsl:call-template name="StringAttributeVariable">			<xsl:with-param name="ObjectName" select="../@Name"/>			<xsl:with-param name="Parent" select="parent::node()"/>			<xsl:with-param name="Namespace" select="'2'"/>			<xsl:with-param name="AttributeName" select="$AttributeName"/>			<xsl:with-param name="AttributeValue" select="."/>		</xsl:call-template>	</xsl:template>	<!--Hier müsste umgestellt werden auf das nächste Template von AdditionalInformation, in dem die einzelnen Elemente ausgelesen werden und nicht nur alles als ein Block-->	<xsl:template match="caex:SourceDocumentInformation">		<xsl:variable name="AttributeName">			<xsl:call-template name="NumberedAttributeName"/>		</xsl:variable>		<xsl:call-template name="StringAttributeVariable">			<xsl:with-param name="ObjectName" select="../@Name"/>			<xsl:with-param name="ParentId" select="'CAEXFile'"/>			<xsl:with-param name="Namespace" select="'2'"/>			<xsl:with-param name="AttributeName" select="$AttributeName"/>			<xsl:with-param name="AttributeValue" select="."/>		</xsl:call-template>	</xsl:template>	<xsl:template match="caex:CAEXFile/caex:AdditionalInformation">		<xsl:variable name="AttributeName">			<xsl:call-template name="NumberedAttributeName"/>		</xsl:variable>		<xsl:variable name="BrowseName">			<xsl:call-template name="AttributeBrowseName"/>		</xsl:variable>		<!-- Create property -->		<xsl:comment>			<xsl:text>Attribute: </xsl:text>CAEXFile.<xsl:value-of select="$BrowseName"/>		</xsl:comment>		<xsl:call-template name="StringAttributeVariable">			<xsl:with-param name="ObjectName" select="CAEXFile"/>			<xsl:with-param name="ParentId" select="'CAEXFile'"/>			<xsl:with-param name="Namespace" select="'2'"/>			<xsl:with-param name="AttributeName" select="$AttributeName"/>			<xsl:with-param name="BrowseName" select="$BrowseName"/>			<xsl:with-param name="AttributeValue" select="."/>		</xsl:call-template>		<!--UAVariable>			<xsl:attribute name="NodeId">				<xsl:value-of select="concat('ns=2;s=CAEXFile_', $AttributeName)"/>			</xsl:attribute>			<xsl:attribute name="BrowseName">				<xsl:value-of select="$BrowseName"/>			</xsl:attribute>			<xsl:attribute name="ParentNodeId">ns=2;s=CAEXFile</xsl:attribute>			<xsl:attribute name="DataType">String</xsl:attribute>			<DisplayName>				<xsl:value-of select="$BrowseName"/>			</DisplayName>			<References>				<Reference ReferenceType="HasTypeDefinition">i=68</Reference>			</References>			<Value>				<xsl:call-template name="AttributeStringValue"/>			</Value>		</UAVariable-->	</xsl:template>	<!-- .........................................................................		Attribute tags of InternalElements and Class definitions	.........................................................................-->	<!-- e.g. {29f2059b-a9eb-4a74-afaa-c065028b5f68}_BoundingBox_height -->	<xsl:template name="GetObjectName">		<xsl:param name="Object"/>		<xsl:choose>			<xsl:when test="$Object/@Name != '' and (name($Object)='SystemUnitClass' or name($Object)='RoleClass' or name($Object)='AttributeTypeClass' or name($Object)='InterfaceClass')">				<xsl:value-of select="$Object/@Name"/>			</xsl:when>			<xsl:when test="$Object/@ID!=''">				<xsl:value-of select="$Object/@ID"/>			</xsl:when>			<!--xsl:when test="$Object/@ID!='' and starts-with($Object/@ID, '{')">				<xsl:value-of select="$Object/@ID"/>			</xsl:when>			<xsl:when test="$Object/@ID!=''">				<xsl:value-of select="concat('{', $Object/@ID, '}')"/>			</xsl:when-->			<xsl:when test="name($Object)='Attribute'">				<xsl:variable name="ParentName">					<xsl:call-template name="GetObjectName">						<xsl:with-param name="Object" select="$Object/parent::*"/>					</xsl:call-template>				</xsl:variable>				<xsl:value-of select="concat($ParentName, '_', $Object/@Name)"/>			</xsl:when>			<xsl:otherwise>				<xsl:value-of select="$Object/@Name"/>			</xsl:otherwise>		</xsl:choose>	</xsl:template>	<xsl:template match="*[name()='Attribute' or name()='Constraint']">		<xsl:variable name="NsId">			<xsl:call-template name="GetNamespaceId"/>		</xsl:variable>		<!-- Get object variables -->		<xsl:variable name="ObjectId">			<xsl:call-template name="GetObjectName">				<xsl:with-param name="Object" select="parent::node()"/>			</xsl:call-template>		</xsl:variable>		<xsl:variable name="ObjectNodeId">			<xsl:choose>				<xsl:when test="parent::*/@ID!=''">					<xsl:value-of select="$ObjectId"/>				</xsl:when>				<xsl:otherwise>					<xsl:value-of select="fn2:remove-space($ObjectId)"/>				</xsl:otherwise>			</xsl:choose>		</xsl:variable>		<xsl:variable name="AttributeDataType">			<xsl:value-of select="@AttributeDataType"/>		</xsl:variable>		<xsl:variable name="Datatype">			<xsl:choose>				<!-- e.g. NominaleScaleType -> NominaleScaleConstraintType -->				<xsl:when test="name()='Constraint'">					<xsl:value-of select="concat(substring(*[1]/name(), 1, string-length(*[1]/name()) - 4),'ConstraintType')"/>				</xsl:when>				<xsl:when test="exslt:node-set($DataTypes)/*[@AML=$AttributeDataType]/@OPCAlias!=''">					<xsl:value-of select="exslt:node-set($DataTypes)/*[@AML=$AttributeDataType]/@OPCAlias"/>				</xsl:when>				<xsl:when test="exslt:node-set($DataTypes)/*[@AML=$AttributeDataType]/@OPCNodeId!=''">					<xsl:value-of select="exslt:node-set($DataTypes)/*[@AML=$AttributeDataType]/@OPCNodeId"/>				</xsl:when>				<xsl:otherwise>					<xsl:value-of select="substring-after($AttributeDataType, ':')"/>				</xsl:otherwise>			</xsl:choose>		</xsl:variable>		<xsl:variable name="ParentClearName">			<xsl:for-each select="ancestor::*[name()='Attribute' or name()='InternalElement']">				<xsl:value-of select="concat(@Name, '.')"/>			</xsl:for-each>		</xsl:variable>		<xsl:comment>			<xsl:value-of select="concat('Attribute: ', $ParentClearName, @Name)"/>		</xsl:comment>		<UAVariable>			<xsl:attribute name="NodeId">				<xsl:call-template name="FormatRef">					<xsl:with-param name="ObjectId" select="concat($ObjectId, '_', @Name)"/>					<xsl:with-param name="Namespace" select="$NsId"/>				</xsl:call-template>			</xsl:attribute>			<xsl:attribute name="BrowseName">				<xsl:value-of select="concat($NsId, ':', @Name)"/>			</xsl:attribute>			<xsl:attribute name="ParentNodeId">				<xsl:call-template name="FormatRef">					<xsl:with-param name="ObjectId" select="$ObjectId"/>					<xsl:with-param name="Namespace" select="$NsId"/>				</xsl:call-template>			</xsl:attribute>			<xsl:if test="$Datatype!=''">				<xsl:attribute name="DataType">					<xsl:value-of select="$Datatype"/>				</xsl:attribute>			</xsl:if>			<DisplayName>				<xsl:value-of select="@Name"/>			</DisplayName>			<References>				<xsl:comment>					<xsl:value-of select="concat('Parent: ', $ParentClearName)"/>				</xsl:comment>				<Reference ReferenceType="HasComponent" IsForward="false">					<xsl:call-template name="FormatRef">						<xsl:with-param name="ObjectId" select="$ObjectId"/>						<xsl:with-param name="Namespace" select="$NsId"/>					</xsl:call-template>				</Reference>				<xsl:comment>HasTypeDefinition: Property Type</xsl:comment>				<Reference ReferenceType="HasTypeDefinition">i=68</Reference>				<xsl:call-template name="References">					<xsl:with-param name="ObjectId" select="concat($ObjectId, '_', @Name)"/>					<xsl:with-param name="Namespace" select="$NsId"/>				</xsl:call-template>			</References>			<xsl:comment>Hier</xsl:comment>			<Value>				<xsl:choose>					<xsl:when test="$Datatype='String' or $Datatype='Boolean' or $Datatype='Int32'">						<xsl:choose>							<xsl:when test="caex:Value!=''">								<xsl:element name="{concat('uax:',$Datatype)}">									<xsl:value-of select="caex:Value"/>								</xsl:element>							</xsl:when>							<xsl:when test="caex:DefaultValue!=''">								<xsl:element name="{concat('uax:',$Datatype)}">									<xsl:value-of select="caex:DefaultValue"/>								</xsl:element>							</xsl:when>						</xsl:choose>					</xsl:when>					<xsl:otherwise>						<xsl:element name="{'uax:String'}">							<xsl:value-of select="caex:Value"/>						</xsl:element>					</xsl:otherwise>				</xsl:choose>			</Value>		</UAVariable>		<xsl:apply-templates select="*"/>	</xsl:template>	<xsl:template name="FormatRef">		<xsl:param name="ObjectId"/>		<xsl:param name="Namespace"/>		<xsl:variable name="CompleteNamespace">			<xsl:choose>				<xsl:when test="$Namespace">					<xsl:value-of select="$Namespace"/>				</xsl:when>				<xsl:otherwise>					<xsl:value-of select="'2'"/>				</xsl:otherwise>			</xsl:choose>		</xsl:variable>		<xsl:choose>			<xsl:when test="matches($ObjectId,'^\{([a-z,A-Z,0-9]*-){4}[a-z,A-Z,0-9]*\}$')">				<xsl:value-of select="concat('ns=' , $CompleteNamespace, ';s=', fn2:remove-space($ObjectId))"/>			</xsl:when>			<xsl:when test="matches($ObjectId,'^([a-z,A-Z,0-9]*-){4}[a-z,A-Z,0-9]*$')">				<xsl:value-of select="concat('ns=' , $CompleteNamespace, ';s={', fn2:remove-space($ObjectId), '}')"/>			</xsl:when>			<xsl:otherwise>				<xsl:value-of select="concat('ns=' , $CompleteNamespace, ';s=', fn2:remove-space($ObjectId))"/>			</xsl:otherwise>		</xsl:choose>	</xsl:template>	<!-- .........................................................................		References to all kind of attributes	.........................................................................-->	<xsl:template name="References">		<xsl:param name="ObjectId"/>		<xsl:param name="Namespace"/>		<xsl:if test="@ID">			<!-- Reference to AML-ID property -->			<xsl:comment>AML-ID</xsl:comment>			<Reference ReferenceType="HasProperty">				<xsl:call-template name="FormatRef">					<xsl:with-param name="ObjectId" select="concat($ObjectId, '_ID')"/>					<xsl:with-param name="Namespace" select="$Namespace"/>				</xsl:call-template>			</Reference>		</xsl:if>		<!-- Reference to Version property -->		<xsl:if test="Version">			<xsl:comment>Version</xsl:comment>			<Reference ReferenceType="HasProperty">				<xsl:call-template name="FormatRef">					<xsl:with-param name="ObjectId" select="concat($ObjectId, '_Version')"/>					<xsl:with-param name="Namespace" select="$Namespace"/>				</xsl:call-template>			</Reference>		</xsl:if>		<!-- Reference to Constraint property -->		<xsl:for-each select="caex:Constraint">			<xsl:comment>Constraint</xsl:comment>			<xsl:comment>TODO: how to model RequiredValues fr the NominalScaleType?</xsl:comment>			<Reference ReferenceType="HasProperty">				<xsl:call-template name="FormatRef">					<xsl:with-param name="ObjectId" select="concat($ObjectId, '_', fn2:remove-space(@Name))"/>					<xsl:with-param name="Namespace" select="$Namespace"/>				</xsl:call-template>			</Reference>		</xsl:for-each>		<!-- References for all Attribute properties -->		<xsl:for-each select="caex:Attribute">			<xsl:comment>				<xsl:text>Attribute: </xsl:text>				<xsl:value-of select="@Name"/>			</xsl:comment>			<Reference ReferenceType="HasComponent">				<xsl:call-template name="FormatRef">					<xsl:with-param name="ObjectId" select="concat($ObjectId, '_', fn2:remove-space(@Name))"/>					<xsl:with-param name="Namespace" select="$Namespace"/>				</xsl:call-template>			</Reference>		</xsl:for-each>		<!-- Reference to SupportedRoleClass -->		<xsl:for-each select="caex:SupportedRoleClass">			<!-- Parse SupportedRoleClass -->			<xsl:variable name="RCName" select="substring-before(@RefRoleClassPath,'/')"/>			<xsl:variable name="RCContent">				<xsl:if test="$RCName!= '' and $RCName!= 'AutomationMLBaseRoleClassLib/AutomationMLBaseRole'">					<xsl:call-template name="GetClass">						<xsl:with-param name="path" select="@RefRoleClassPath"/>					</xsl:call-template>				</xsl:if>			</xsl:variable>			<xsl:variable name="LibName" select="ancestor::RoleClassLib[1]/@Name"/>			<!-- Create HasAMLRoleReference -->			<xsl:comment>				<xsl:text>SupportedRoleClass: </xsl:text>				<xsl:value-of select="@RefRoleClassPath"/>			</xsl:comment>			<xsl:variable name="LibNsId">				<xsl:call-template name="GetNamespaceIdByName">					<xsl:with-param name="Namespace" select="$RCName"/>				</xsl:call-template>			</xsl:variable>			<Reference ReferenceType="HasAMLRoleReference">				<xsl:call-template name="FormatRef">					<xsl:with-param name="ObjectId" select="exslt:node-set($RCContent)/caex:RoleClass/@Name"/>					<xsl:with-param name="Namespace" select="$LibNsId"/>				</xsl:call-template>			</Reference>		</xsl:for-each>		<!-- Reference to ExternalInterface objects -->		<xsl:for-each select="caex:ExternalInterface">			<xsl:comment>				<xsl:text>ExternalInterface: </xsl:text>				<xsl:value-of select="@Name"/>			</xsl:comment>			<Reference ReferenceType="HasComponent">				<xsl:call-template name="FormatRef">					<xsl:with-param name="ObjectId" select="@ID"/>					<xsl:with-param name="Namespace" select="$Namespace"/>				</xsl:call-template>				<!--xsl:value-of select="fn2:remove-space(concat($CompleteObjectId, '_', @Name))"/-->			</Reference>		</xsl:for-each>		<!-- Reference to InternalElement objects -->		<xsl:for-each select="caex:InternalElement">			<xsl:comment>				<xsl:text>InternalElement: </xsl:text>				<xsl:value-of select="@Name"/>			</xsl:comment>			<Reference ReferenceType="HasComponent">				<xsl:call-template name="FormatRef">					<xsl:with-param name="ObjectId" select="@ID"/>					<xsl:with-param name="Namespace" select="$Namespace"/>				</xsl:call-template>			</Reference>		</xsl:for-each>	</xsl:template>	<!-- ***************************************************************************  ***  Hierarchical elements********************************************************************************* -->	<!-- Create Collection as parent for InstanceHierarchies and the differnt types of libraries -->	<xsl:template name="HierarchicalElement">		<xsl:param name="Name"/>		<xsl:param name="ChildName"/>		<xsl:comment>			<xsl:value-of select="concat('Collection: CAEXFile.', $Name)"/>		</xsl:comment>		<xsl:if test="*[local-name()=$ChildName]">			<UAObject>				<xsl:attribute name="NodeId">					<xsl:call-template name="FormatRef">						<xsl:with-param name="ObjectId" select="concat('CAEXFile_', $Name)"/>					</xsl:call-template>				</xsl:attribute>				<xsl:attribute name="BrowseName">					<xsl:value-of select="concat('2:', $Name)"/>				</xsl:attribute>				<xsl:attribute name="ParentNodeId">					<xsl:call-template name="FormatRef">						<xsl:with-param name="ObjectId" select="'CAEXFile'"/>					</xsl:call-template>				</xsl:attribute>				<DisplayName>					<xsl:value-of select="$Name"/>				</DisplayName>				<References>					<Reference ReferenceType="HasComponent" IsForward="false">						<xsl:call-template name="FormatRef">							<xsl:with-param name="ObjectId" select="'CAEXFile'"/>						</xsl:call-template>					</Reference>					<Reference ReferenceType="HasTypeDefinition">i=61</Reference>					<xsl:for-each select="*[local-name()=$ChildName]">						<xsl:comment>							<xsl:value-of select="concat($ChildName, ': ', @Name)"/>						</xsl:comment>						<Reference ReferenceType="HasComponent">							<xsl:choose>								<xsl:when test="$Name='InstanceHierarchies'">									<xsl:call-template name="FormatRef">										<xsl:with-param name="ObjectId" select="concat('InstanceHierarchy_', @Name)"/>									</xsl:call-template>								</xsl:when>								<xsl:otherwise>									<xsl:variable name="NsId">										<xsl:call-template name="GetNamespaceId"/>									</xsl:variable>									<xsl:call-template name="FormatRef">										<xsl:with-param name="ObjectId" select="name(.)"/>										<xsl:with-param name="Namespace" select="$NsId"/>									</xsl:call-template>								</xsl:otherwise>							</xsl:choose>						</Reference>					</xsl:for-each>				</References>			</UAObject>		</xsl:if>		<xsl:apply-templates select="node()[local-name()=$ChildName]"/>	</xsl:template>	<!-- .........................................................................		External Interfaces	.........................................................................-->	<xsl:template match="caex:ExternalInterface">		<xsl:variable name="NsId">			<xsl:call-template name="GetNamespaceId"/>		</xsl:variable>		<!-- Get object variables -->		<xsl:variable name="ParentName" select="../@Name"/>		<xsl:variable name="ParentId" select="../@ID"/>		<xsl:variable name="ParentIdString">			<xsl:call-template name="GetObjectName">				<xsl:with-param name="Object" select="parent::node()"/>			</xsl:call-template>		</xsl:variable>		<xsl:variable name="ParentNodeId">			<xsl:call-template name="FormatRef">				<xsl:with-param name="ObjectId" select="$ParentIdString"/>				<xsl:with-param name="Namespace" select="$NsId"/>			</xsl:call-template>		</xsl:variable>		<xsl:variable name="InterfaceName" select="@Name"/>		<xsl:variable name="ObjectId">			<xsl:call-template name="GetObjectName">				<xsl:with-param name="Object" select="."/>			</xsl:call-template>		</xsl:variable>		<xsl:variable name="InterfaceNodeId">			<xsl:call-template name="FormatRef">				<xsl:with-param name="ObjectId" select="$ObjectId"/>				<xsl:with-param name="Namespace" select="$NsId"/>			</xsl:call-template>		</xsl:variable>		<xsl:comment>			<xsl:text>ExternalInterface: </xsl:text>			<xsl:value-of select="concat($ParentName, '.', $InterfaceName)"/>		</xsl:comment>		<UAObject>			<xsl:attribute name="NodeId">				<xsl:value-of select="$InterfaceNodeId"/>			</xsl:attribute>			<xsl:attribute name="BrowseName">				<xsl:value-of select="concat($NsId, ':', @Name)"/>			</xsl:attribute>			<xsl:attribute name="ParentNodeId">				<xsl:value-of select="$ParentNodeId"/>			</xsl:attribute>			<!--xsl:attribute name="DataType">String</xsl:attribute-->			<DisplayName>				<xsl:value-of select="@Name"/>			</DisplayName>			<References>				<!--Reference ReferenceType="HasComponent" IsForward="false"></Reference-->				<xsl:comment>TODO: correct TypeDefinition</xsl:comment>				<Reference ReferenceType="HasTypeDefinition">i=68</Reference>				<xsl:call-template name="References">					<xsl:with-param name="ObjectId" select="@ID"/>					<xsl:with-param name="Namespace" select="$NsId"/>				</xsl:call-template>				<xsl:for-each select="$InternalLinks/ua:InternalLinks/ua:InternalLink[@InterfaceSideA=$InterfaceName and @ParentSideA=$ParentId]">					<xsl:comment>TODO: handle InternalLinks that use the name of the parent instead of the ID or already contain '{}'.</xsl:comment>					<xsl:comment>						<xsl:value-of select="concat('InternalLink: ', @Name)"/>					</xsl:comment>					<xsl:comment>						<xsl:value-of select="concat('{',@ParentSideB,'}_',@InterfaceSideB)"/>					</xsl:comment>					<xsl:variable name="PartnerSideB">						<Partner>							<xsl:attribute name="ID" select="@ParentSideB"/>							<xsl:attribute name="Name" select="@InterfaceSideB"/>						</Partner>					</xsl:variable>					<xsl:variable name="Partner">						<xsl:value-of select="$document-root//*[@ID=$PartnerSideB//@ID]//*[@Name=$PartnerSideB//@Name]/@ID"/>					</xsl:variable>					<Reference ReferenceType="HasAMLInternalLink">						<xsl:call-template name="FormatRef">							<xsl:with-param name="ObjectId" select="$Partner"/>							<xsl:with-param name="Namespace" select="$NsId"/>						</xsl:call-template>					</Reference>				</xsl:for-each>				<xsl:for-each select="$InternalLinks/ua:InternalLinks/ua:InternalLink[@InterfaceSideB=$InterfaceName and @ParentSideB=$ParentId]">					<xsl:comment>						<xsl:value-of select="concat('InternalLink: ', @Name)"/>					</xsl:comment>					<xsl:comment>						<xsl:value-of select="concat('{',@ParentSideA,'}_',@InterfaceSideA)"/>					</xsl:comment>					<xsl:variable name="PartnerSideA">						<Partner>							<xsl:attribute name="ID" select="@ParentSideA"/>							<xsl:attribute name="Name" select="@InterfaceSideA"/>						</Partner>					</xsl:variable>					<xsl:variable name="Partner">						<xsl:value-of select="$document-root//*[@ID=$PartnerSideA//@ID]//*[@Name=$PartnerSideA//@Name]/@ID"/>					</xsl:variable>					<Reference ReferenceType="HasAMLInternalLink" IsForward="false">						<xsl:call-template name="FormatRef">							<xsl:with-param name="ObjectId" select="$Partner"/>							<xsl:with-param name="Namespace" select="$NsId"/>						</xsl:call-template>					</Reference>				</xsl:for-each>			</References>		</UAObject>		<!-- Create referred UAVariables and UAObjects -->		<xsl:apply-templates select="@ID|node()"/>	</xsl:template>	<!-- .........................................................................		InternalElements	.........................................................................-->	<xsl:template match="caex:InternalElement">		<xsl:variable name="NsId">			<xsl:call-template name="GetNamespaceId"/>		</xsl:variable>		<!-- Parse SystemUnitClass -->		<xsl:variable name="UCName" select="substring-before(@RefBaseSystemUnitPath,'/')"/>		<xsl:variable name="UCContent">			<xsl:if test="$UCName!= '' and $UCName!= 'AutomationMLBaseRoleClassLib/AutomationMLBaseRole'">				<xsl:call-template name="GetClass">					<xsl:with-param name="path" select="@RefBaseSystemUnitPath"/>				</xsl:call-template>			</xsl:if>		</xsl:variable>		<xsl:variable name="UCLibId">			<xsl:call-template name="GetNamespaceIdByName">				<xsl:with-param name="Namespace" select="$UCName"/>			</xsl:call-template>		</xsl:variable>		<!--Test><xsl:copy-of select="$UCContent"/></Test-->		<!-- Create UAObject -->		<UAObject>			<xsl:attribute name="NodeId">				<xsl:call-template name="FormatRef">					<xsl:with-param name="ObjectId" select="@ID"/>					<xsl:with-param name="Namespace" select="$NsId"/>				</xsl:call-template>			</xsl:attribute>			<xsl:attribute name="BrowseName">				<xsl:value-of select="concat($NsId, ':', @Name)"/>			</xsl:attribute>			<DisplayName>				<xsl:value-of select="@Name"/>			</DisplayName>			<xsl:if test="Description">				<Documentation>					<xsl:value-of select="caex:Description"/>				</Documentation>			</xsl:if>			<References>				<xsl:if test="exslt:node-set($UCContent)/*!=''">					<!-- Reference to class definition -->					<xsl:comment>						<xsl:text>Class definition</xsl:text>					</xsl:comment>					<Reference ReferenceType="HasTypeDefinition">						<xsl:call-template name="FormatRef">							<xsl:with-param name="ObjectId" select="exslt:node-set($UCContent)/caex:SystemUnitClass/@Name"/>							<xsl:with-param name="Namespace" select="$UCLibId"/>						</xsl:call-template>					</Reference>				</xsl:if>				<xsl:call-template name="References">					<xsl:with-param name="ObjectId" select="@ID"/>					<xsl:with-param name="Namespace" select="$NsId"/>				</xsl:call-template>			</References>		</UAObject>		<!-- Create referred UAVariables and UAObjects -->		<xsl:apply-templates select="@ID|node()"/>	</xsl:template></xsl:stylesheet>